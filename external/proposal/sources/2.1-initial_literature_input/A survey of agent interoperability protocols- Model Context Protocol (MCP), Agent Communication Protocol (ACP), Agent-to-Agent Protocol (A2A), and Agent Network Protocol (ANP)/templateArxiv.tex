\documentclass{article}


\usepackage{PRIMEarxiv}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{lipsum}
\usepackage{fancyhdr}       % header
\usepackage{graphicx}       % graphics
\graphicspath{{media/}}     % organize your images and other figures under media/ folder
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage[table]{xcolor}
\usepackage{enumitem}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}


% \usepackage[utf8]{inputenc}
\usepackage{amssymb}
% \renewcommand{\arraystretch}{1.3}

%Header
\pagestyle{fancy}
\thispagestyle{empty}
\rhead{ \textit{ }} 

% Update your Headers here
% \fancyhead[LO]{Running Title for Header}
% \fancyhead[RE]{Firstauthor and Secondauthor} % Firstauthor et al. if more than 2 - must use \documentclass[twoside]{article}



  
%% Title
\title{
A Survey of Agent Interoperability Protocols: Model Context Protocol (MCP), Agent Communication Protocol (ACP), Agent-to-Agent Protocol (A2A), and Agent Network Protocol (ANP)}

%%%% Cite as
%%%% Update your official citation here when published 

\author{
  Abul Ehtesham \\
  Kent State University \\
  Kent, OH, USA \\
  \texttt{aehtesha@kent.edu} \\
  \And
  Aditi Singh \\
  Cleveland State University \\
  Cleveland, OH, USA \\
  \texttt{a.singh22@csuohio.edu} \\
  \And
  Gaurav Kumar Gupta \\
  Youngstown State University \\
  Youngstown, OH, USA \\
  \texttt{gkgupta@student.ysu.edu} \\
  \And
  Saket Kumar \\
  Northeastern University \\
  Boston, MA, USA \\
  \texttt{kumar.sak@northeastern.edu} \\
}



% \author{
%   Author1, Author2 \\
%   Affiliation \\
%   Univ \\
%   City\\
%   \texttt{\{Author1, Author2\}email@email} \\
%   %% examples of more authors
%    \And
%   Author3 \\
%   Affiliation \\
%   Univ \\
%   City\\
%   \texttt{email@email} \\
%   %% \AND
%   %% Coauthor \\
%   %% Affiliation \\
%   %% Address \\
%   %% \texttt{email} \\
%   %% \And
%   %% Coauthor \\
%   %% Affiliation \\
%   %% Address \\
%   %% \texttt{email} \\
%   %% \And
%   %% Coauthor \\
%   %% Affiliation \\
%   %% Address \\
%   %% \texttt{email} \\
% }


\begin{document}
\maketitle


\begin{abstract}
Large language model (LLM)-powered autonomous agents demand robust, standardized protocols to integrate tools, share contextual data, and coordinate tasks across heterogeneous systems. Ad-hoc integrations are difficult to scale, secure, and generalize across domains. This survey examines four emerging agent communication protocols: Model Context Protocol (MCP), Agent Communication Protocol (ACP), Agent-to-Agent Protocol (A2A), and Agent Network Protocol (ANP), each addressing interoperability in distinct deployment contexts. MCP provides a JSON-RPC client-server interface for secure tool invocation and typed data exchange. ACP defines a general-purpose communication protocol over RESTful HTTP, supporting MIME-typed multipart messages and both synchronous and asynchronous interactions. Its lightweight and runtime-independent design enables scalable agent invocation, while features like session management, message routing, and integration with role-based and decentralized identifiers (DIDs).A2A enables peer-to-peer task delegation using capability-based Agent Cards, supporting secure and scalable collaboration across enterprise agent workflows. ANP supports open-network agent discovery and secure collaboration using W3C decentralized identifiers (DIDs) and JSON-LD graphs. The protocols are compared across multiple dimensions, including interaction modes, discovery mechanisms, communication patterns, and security models. Based on the comparative analysis, a phased adoption roadmap is proposed: beginning with MCP for tool access, followed by ACP for structured, multimodal messaging, session-aware interaction, and both online and offline agent discovery across scalable, HTTP-based deployments, A2A for collaborative task execution, and extending to ANP for decentralized agent marketplaces. This work provides a comprehensive foundation for designing secure, interoperable, and scalable ecosystems of LLM-powered agents.
\end{abstract}




% keywords can be removed
\keywords{
Large Language Models (LLMs), Agent Communication, Interoperability Protocols, Model Context Protocol (MCP), Agent Communication Protocol (ACP), Agent-to-Agent Protocol (A2A), Agent Network Protocol (ANP), Autonomous Agents, Multimodal Messaging, Decentralized Identity (DID) , peer-to-peer
}




\section{Introduction}


Large Language Models (LLMs) have become central to modern artificial intelligence, powering autonomous agents that operate across cloud, edge, and desktop environments~\cite{brown2020language,bommasani2021opportunities}. These agents~\cite{Wang_2024} ingest contextual information, execute tasks, and interact with external services or tools. However, inconsistent and fragmented interoperability practices make it difficult to integrate, secure, and scale communication among LLM-driven agents~\cite{mialon2023augmented}.

Interoperability (the ability of distinct agents and systems to discover capabilities, exchange context, and coordinate actions seamlessly) is essential for modular, reusable, and resilient multi-agent~\cite{guo2024largelanguagemodelbased} workflows. Standardized protocols reduce development overhead, improve security, and enable cross-platform collaboration. Clear, universally adopted standards remain nascent.

This survey examines four emerging agent communication protocols, each targeting a different interoperability tier:

\begin{itemize}
  \item \textbf{Model Context Protocol (MCP)}: A JSON-RPC client–server interface for secure context ingestion and structured tool invocation. MCP streamline the integration of large language models (LLMs) with external data sources and tools. MCP addresses the challenges of fragmented and custom-built integrations by providing a universal, model-agnostic interface for AI systems to access and interact with diverse resources~\cite{mcp2024introduction,singh2025mcp,ray2025mcp}. MCP was launched by Anthropic in Novemeber 2024.
  \item \textbf{Agent-to-Agent Protocol (A2A)}: Enable secure, structured, and interoperable collaboration between AI agents across platforms, vendors, and environments. A2A is designed to support peer-to-peer agent interactions using capability-based representations known as Agent Cards, which describe what an agent can do and how it can be securely invoked. A2A supports asynchronous, event-driven communication through HTTP and Server-Sent Events (SSE), making it suitable for distributed, scalable agent ecosystems,~\cite{google2024a2a}. A2A was launched by Google in April 2025.
  \item \textbf{Agent Communication Protocol (ACP)}: ACP is a general-purpose protocol for agent communication that uses RESTful HTTP interfaces to support MIME-typed multipart messages and both synchronous and asynchronous interactions. This REST-based communication model enables lightweight, runtime-independent agent invocation, making ACP well-suited for scalable system integration. ACP includes structured session management, message routing, and a flexible authentication model that integrates with role-based access control (RBAC) and decentralized identity (DID) systems. It is compatible with a wide range of agent frameworks and deployment models, from lightweight stateless utilities to long-running, stateful services. ACP also supports agent discovery through runtime APIs, offline packaging, and manifest-based metadata. ACP was launched by IBM in March 2025~\cite{beeai2024acp}.
  \item \textbf{Agent Network Protocol (ANP)}: The Agent Network Protocol (ANP) is an open-source communication framework designed to enable secure, decentralized collaboration among AI agents across the open internet. Unlike traditional client-server architectures, ANP adopts a peer-to-peer (P2P) model, allowing agents to autonomously discover, authenticate, and interact with one another without centralized intermediaries ~\cite{anp2024github, anp2024website}.
\end{itemize}

Architectural details, integration approaches, communication patterns, and security considerations are reviewed for each protocol. A comparison highlights trade-offs in interaction modes, discovery mechanisms, communication models, and security frameworks. A phased adoption roadmap sequences MCP, A2A, ACP, and ANP to guide progressive deployment in real-world agent ecosystems.

The remainder of the paper is organized as follows. Section 2 discusses challenges in agent interoperability. Section 3 reviews background and related work. Sections 4–7 describe the architectures of MCP, A2A, ACP, and ANP, respectively. Section 8 presents the comparative evaluation. Section 9 outlines the phased adoption roadmap. Section 10 concludes and suggests future research directions.





% \begin{figure*}[ht]
%     \centering
%     \begin{subfigure}[b]{0.48\linewidth}
%         \includegraphics[width=0.6\linewidth]{challnge.png}
%         \caption{Challenges}
%         \label{fig:left}
%     \end{subfigure}
%     \hfill
%     \begin{subfigure}[b]{0.48\linewidth}
%         \includegraphics[width=\linewidth]{solution.png}
%         \caption{Solution}
%         \label{fig:right}
%     \end{subfigure}
%     \caption{Overall}
%     \label{fig:ecosystem2}
% \end{figure*}

% \begin{figure}
%     \centering
%     \includegraphics[width=0.5\linewidth]{security_challenges.png}
%     \caption{Protocol-aligned solution to challenges in agent communication}
%     \label{fig:enter-label}
% \end{figure}


% \begin{figure}
%     \centering
%     \includegraphics[width=0.5\linewidth]{ecosystemdiagram.png}
%     \caption{Ecosystem}
%     \label{fig:ecosystem}
% \end{figure}


\section{Challenges and Solutions in Agent Protocol Interoperability}
Despite the emergence of multiple open protocols like MCP, ACP, A2A, and ANP, achieving seamless agent interoperability in real-world AI systems remains a non-trivial task. This section identifies key challenges encountered in agent-based architectures and highlights how each protocol addresses them with purpose-built design principles.

\textbf{Lack of Context Standardization for LLMs:}
Large Language Models (LLMs) require contextual grounding to produce accurate outputs. However, existing application architectures provide no unified mechanism to deliver structured context to LLMs, leading to ad hoc tool integrations and unreliable behavior.
\textit{Solution:} The Model Context Protocol (MCP) addresses this by standardizing how applications deliver tools, datasets, and sampling instructions to LLMs, akin to a USB-C for AI. It supports flexible plug-and-play tools, safe infrastructure integration, and compatibility across LLM vendors.

\begin{figure}[b]
    \centering
    \includegraphics[width=0.5\linewidth]{security_challenges.png}
    \caption{Protocol-aligned solution to challenges in agent communication}
    \label{fig:enter-label}
\end{figure}


\textbf{Communication Barriers Between Heterogeneous Agents:}
Enterprise systems often consist of agents built using different stacks and frameworks, resulting in isolated behavior and poor collaboration.
\textit{Solution:} The Agent Communication Protocol (ACP) offers a RESTful, SDK-optional interface with open governance under the Linux Foundation. It enables asynchronous-first interactions, offline discovery, and vendor-neutral execution, bridging interoperability gaps at scale.

\textbf{Absence of Unified Agent Collaboration Standards:}
Even when agents communicate, there's no shared framework for dynamic negotiation, capability sharing, and coordination.
\textit{Solution:} The Agent2Agent (A2A) protocol introduces a multimodal communication standard to unlock dynamic interaction between opaque, autonomous agents—regardless of framework. It simplifies enterprise integration and supports shared task management and user experience negotiation.





\textbf{Internet-Agnostic Agent Communication:}
The modern internet is optimized for human interaction but suboptimal for autonomous agents, which require low-latency, API-native communication and decentralized identity validation.
\textit{Solution:} The Agent Network Protocol (ANP) provides a layered protocol architecture incorporating decentralized identity (W3C DID), semantic web principles, and encrypted communication to facilitate cross-platform agent collaboration over the open internet.



Together, these protocols aim to transform fragmented AI ecosystems into robust, secure, and interoperable agent networks scalable across organizational and vendor boundaries. See Table~\ref{tab:agent-protocol-comparison} for a detailed comparative overview.



% \section{Challenges in Agent Interoperability}

% Despite the evolution of standards, several core challenges remain unresolved:

% \begin{itemize}
%     \item \textbf{Semantic heterogeneity}: Agents frequently employ different ontologies or domain-specific vocabularies, which inhibits shared understanding~\cite{gruber1995toward}.
%     \item \textbf{Protocol fragmentation}: The ecosystem lacks unifying standards, resulting in numerous incompatible and vendor-specific protocols~\cite{miller2003web}.
%     \item \textbf{Integration complexity}: Developers often write extensive custom code to interface agents with external tools or services~\cite{hendler2001agents}.
%     \item \textbf{Scalability}: Many agent frameworks are not optimized for distributed, real-time, or multi-agent orchestration at production scale~\cite{wooldridge2009introduction}.
%     \item \textbf{Limited adoption of prior standards}: Efforts like FIPA struggled to gain industry traction due to complexity and inflexible architectures~\cite{luck2005agent}.
% \end{itemize}

% \begin{figure}
%     \centering
%     \includegraphics[width=\linewidth]{Interoperability Solutions for LLM Agents.png}
%     \caption{Protocol Solution for Interoperability Challenges}
%     \label{fig:solution}
% \end{figure}



\section{Background and Related Work}
\label{sec:background}



Autonomous agents powered by large language models (LLMs) are rapidly being adopted across industries to automate complex tasks, yet disparate frameworks and ad-hoc integrations hinder robust interoperability, security, and scalability~\cite{bommasani2021opportunities,mialon2023augmented}.  Recent surveys have begun to characterize the landscape of LLM-based multi-agent systems, categorizing collaboration patterns, memory architectures, and orchestration strategies~\cite{tran2025multi,guo2024survey,yan2025beyond}.  However, these works largely focus on high-level workflows and neglect the underlying protocols necessary for dynamic peer discovery, capability negotiation, and secure tool invocation.

Effective interoperability—enabling agents to discover capabilities, share context, and coordinate actions—is critical for building modular, reusable, and resilient multi-agent systems.  Early efforts in dynamic discovery have introduced metadata manifests and capability descriptors to allow runtime agent registration and lookup~\cite{sheriff2024dynamic}, while recent work on automated tool testing frameworks (e.g., TOOLFUZZ) highlights the challenges of ensuring compatibility across evolving API surfaces~\cite{milev2024toolfuzz}.  Yet, no unified protocol has emerged that specifies how agents should announce their interfaces, authenticate peers, or negotiate context sharing across heterogeneous LLM frameworks.

In response to this gap, recent proposals such as the Model Context Protocol (MCP), Agent Communication Protocol (ACP), Agent2Agent Protocol (A2A)  and Agent Network Protocol (ANP) aim to define lightweight, formal interfaces for context ingestion, performative messaging, and peer discovery using JSON-RPC schemas~\cite{mcp2024introduction,beeai2024acp,google2024a2a, anp2024github, anp2024website}. Each protocol is examined in detail, followed by a comparative analysis and a roadmap for their integration within emerging multi-agent ecosystems.


\subsection{AI Agents: Definition and Scope}
\label{sec:definition}

An \emph{AI agent} is defined as any autonomous software entity that perceives its environment through inputs (e.g., user queries, sensor data) and acts upon it via outputs (e.g., API calls, messages) to achieve designated goals~\cite{russell2010aima}.  Agents operate within environments characterized along dimensions such as observability, determinism, episodicity, and dynamicity, and may employ sensors and actuators to interact with physical or virtual world models~\cite{russell2010aima,wooldridge2009introduction}.  

According to Franklin and Graesser’s taxonomy, agents can be categorized based on attributes like autonomy, sociability, reactivity, and adaptability, reflecting their ability to function in open, multi-agent settings~\cite{franklin1997taxonomy}.  Jennings emphasizes proactive goal generation, complex planning, and robust recovery capabilities under uncertainty as key distinguishing features from simple reactive programs~\cite{jennings2000agent}.  Wooldridge further identifies four core properties—\emph{autonomy}, \emph{social ability}, \emph{reactivity}, and \emph{pro‐activeness}, that enables agents to operate without direct human intervention, collaborate with peers, and pursue long‐term objectives~\cite{wooldridge2009introduction}.  

Agent architectures span from simple rule‐based reactive models, where actions are direct responses to percepts, to rich deliberative frameworks such as Belief‐Desire‐Intention (BDI) systems that support symbolic reasoning, dynamic plan execution, and intention reconsideration.  In multi-agent systems, coordination is achieved through communication protocols, negotiation strategies, and organizational structures, laying the groundwork for LLM‐powered ecosystems that require robust interoperability, security, and scalability.  This broad yet precise definition underpins our subsequent review of communication standards, orchestration frameworks, and protocol designs.


\subsection{Early Symbolic Agent Languages—Evolution of Agent Communication Standards}
The first formal agent messaging languages emerged in the early 1990s with the goal of providing a standardized “envelope” and performative vocabulary for knowledge‐based systems.  The \textbf{Knowledge Query and Manipulation Language (KQML)} introduced by Genesereth and Ketchpel defined a set of speech‐act performatives (e.g., \texttt{ask‐if}, \texttt{tell}, \texttt{reply}) along with a flexible message envelope supporting parameters such as \texttt{:content}, \texttt{:language}, \texttt{:ontology}, \texttt{:receiver}, and \texttt{:reply‐with}.  KQML also specified content‐language bindings (commonly KIF) to express propositions in a machine‐interpretable form~\cite{genesereth1993kqml,finin1994kqml}.  Although widely used in DARPA’s Open Knowledge Base and Agent projects, KQML’s lack of formal semantics for performatives and heavyweight XML‐style encodings hindered large‐scale deployments.

Building on KQML, the \textbf{FIPA Agent Communication Language (FIPA‐ACL)}—ratified by the Foundation for Intelligent Physical Agents in 2000—refined the notion of communicative acts by prescribing precise pre‐ and post‐condition semantics grounded in agents’ mental states (beliefs, desires, intentions).  FIPA‐ACL defined a richer set of performatives (e.g., \texttt{agree}, \texttt{refuse}, \texttt{request}), standardized content languages (e.g., SL0, SL1), and outlined interaction protocols for common patterns such as \emph{contract net}, \emph{iterated contract net}, and \emph{subscribe/notify}~\cite{fipa2000acl}.  Reference implementations in platforms like JADE and JACK offered Java‐based agent containers and message‐handling APIs, yet the complexity of FIPA’s ontology management, coupled with verbose XML encodings, limited its uptake to academic and defense use cases rather than lightweight, industry‐grade systems.




\subsection{Service-Oriented Integrations and Retrieval-Augmented Generation}
The early 2000s witnessed the rise of service-oriented architectures (SOA), in which enterprise systems exposed functionality as web services (SOAP, WSDL, WS-* standards) and registered endpoints in UDDI repositories~\cite{curbera2002web}. Message-oriented middleware and enterprise service buses (ESBs) such as Apache Camel and Mule ESB facilitated protocol bridging, message routing, and payload transformation, leveraging patterns like content-based routing, message splitting, and aggregation~\cite{hohpe2006enterprise}. While SOA and ESBs decoupled service producers from consumers, they often incurred high operational complexity, brittle adapters, and configuration sprawl as APIs evolved and security requirements tightened.

With the advent of large language models, \textbf{Retrieval-Augmented Generation (RAG)} emerged in 2020 to integrate external knowledge into generation pipelines by coupling dense vector retrieval with autoregressive decoding~\cite{lewis2020rag}. RAG systems encode queries and documents in a shared embedding space (e.g., DPR) to fetch top-$k$ relevant passages, then condition LLM outputs on retrieved context to reduce hallucinations and enable dynamic knowledge updates~\cite{izacard2021towards}. Despite improving factuality and flexibility, RAG frameworks treat retrieval and generation as separate batch processes and do not prescribe how LLMs should translate grounded content into executable actions or orchestrate multi-step workflows—highlighting a need for protocol-level standards that unify knowledge grounding with action invocation.




\subsection{LLM Agents and Function Calling}
The rapid evolution of large language models (LLMs) such as GPT-3.5, GPT-4, Claude, and Gemini has fundamentally transformed agent design by enabling zero- and few-shot understanding of complex natural language instructions without bespoke rule engines~\cite{bommasani2021opportunities}.  These foundation models can parse user intent, plan multi-step workflows, and maintain dialogue coherence across diverse domains, opening the door to “LLM agents” that combine linguistic reasoning with external tool execution.

To operationalize tool use, OpenAI introduced \textbf{function calling} in 2023, a lightweight protocol whereby an LLM can output a JSON-formatted signature corresponding to a predefined API endpoint~\cite{openai2023function}.  Under this paradigm, developers supply the model with a catalog of function definitions—each described by a name, JSON schema for arguments, and descriptive help text—and the model decides at generation time whether to invoke a function, emitting well-formed JSON that can be parsed and executed by downstream systems.  This approach unifies natural language understanding and action invocation, enabling real-time data fetches, database queries, and transactional operations from within a single LLM response.

Building on this core capability, several frameworks have emerged to simplify agent development:
\begin{itemize}
  \item \textbf{LangChain} provides abstractions for chaining LLM calls, memory buffers, and function invocation in modular workflows, with built-in support for retrievers, vector stores, and agent loops~\cite{chase2022langchain}.
  \item \textbf{LlamaIndex} (formerly GPT Index) focuses on integrating LLMs with custom knowledge bases, offering document loaders, index wrappers, and a “tool registry” that maps user queries to API calls~\cite{wu2023llamaindex}.
  \item The \textbf{OpenAI Plugin Store} enables third-party tool providers to register plugins that expose RESTful interfaces, metadata, and authentication flows, which can be discovered and invoked by any model with plugin access~\cite{openai2023plugin}.
\end{itemize}

Despite these advances, current function-calling ecosystems suffer from several limitations.  Tool definitions are typically static: agents must be re-initialized whenever new APIs are added or schemas change, preventing truly dynamic discovery.  Security boundaries—such as authentication tokens, rate limits, and access control—are ad-hoc and framework-specific, increasing the risk of unauthorized calls.  Moreover, each framework employs its own metadata conventions, hindering cross-framework reuse of tools and requiring bespoke adapters for interoperability~\cite{liu2024autotool}.  Addressing these challenges requires protocol-level standards that prescribe a common schema for function metadata, dynamic capability negotiation, and end-to-end security guarantees across heterogeneous LLM agent platforms.




\subsection{Orchestration and Lightweight Agent Frameworks}
Recent advances have extended the capabilities of LLMs beyond reasoning to include orchestration of  external tool invocation. \textbf{Toolformer} employs a self-supervised masking strategy that exposes potential API calls during pretraining, enabling the model to learn when and how to invoke functions as part of its text generation~\cite{le2023toolformer}.  \textbf{ReAct} interleaves chain-of-thought reasoning with explicit action calls, allowing models to alternate between “thinking” steps and tool invocations based on intermediate observations~\cite{yao2023react}.  These approaches unify reasoning and action at the single-agent level but do not address peer discovery or multi-agent coordination.

Complementing these algorithmic techniques, several lightweight frameworks have emerged to suppprt multi-agent orchestration with minimal boilerplate (Table~\ref{tab:frameworks}). Additional orchestration systems, such as AutoGPT’s autonomous loops~\cite{autogen2023} and Reflexion’s iterative self-improvement mechanism~\cite{shinn2023reflexion}, highlight the value of feedback and adaptation in agent workflows, However, these frameworks continue to rely on static tool registries and bespoke communication layers.  Across these approaches, the lack of a standardized protocol for capability advertisement, peer authentication, and cross-framework composition contributes to fragmentation-hindering the emergence of a cohesive, interoperable agent ecosystem.


\begin{table}[!t]
  \centering
  \renewcommand{\arraystretch}{1.3}
  \rowcolors{2}{gray!10}{white}
  \captionsetup{justification=centering}
  \caption{Lightweight LLM Agent Frameworks}
  \label{tab:frameworks}
  \begin{tabularx}{\textwidth}{|
    >{\centering\arraybackslash}p{2.5cm}|
    >{\raggedright\arraybackslash}X|
    >{\raggedright\arraybackslash}p{2.5cm}|}
    \hline
    \rowcolor{gray!30}
    % \toprule
    \textbf{Framework} & \textbf{Core Feature} & \textbf{Reference} \\
    \hline
    CrewAI            & High-level crew abstractions for role assignment, subtask delegation, and message routing among agents      & \cite{crewai2024}       \\
    SmolAgents        & Single-file Python library combining retrieval, vision, and agent loop primitives for rapid prototyping           & \cite{smolagents2024}   \\
    AG2 (AutoGen)     & Open-source AgentOS with human-in-the-loop checkpoints, policy enforcement hooks, and lifecycle management       & \cite{ag22025}          \\
    Semantic Kernel   & Enterprise-grade SDK unifying memory stores, planning modules, and plugin orchestration across sessions        & \cite{semantickernel2024}\\
    Swarm             & Stateless multi-agent coordination via JSON-RPC routines, spawning and aggregating parallel agent tasks         & \cite{openai2024swarm}  \\
    \bottomrule
  \end{tabularx}
\end{table}







\subsection{Protocol Evolution Timeline}
\label{sec:timeline}

The evolution of agent interoperability is illustrated through a visual timeline (Figure~\ref{fig:timeline}) and a detailed table (Table~\ref{tab:timeline}). The timeline captures high-level milestones, while the table offers technical detail, describing each development alongside key contributions. Together, these representations outline the trajectory of interoperability standards and protocols over time.



% \begin{table}[ht]
%   \centering
%   \renewcommand{\arraystretch}{1.3}
%   \rowcolors{2}{gray!10}{white}
%   \captionsetup{justification=centering}
%   \caption{Threats and Mitigation Strategies Across the MCP Lifecycle}
%   \label{tab:mcp-threats}
% \begin{tabularx}{\textwidth}{|
%     >{\centering\arraybackslash}p{2.1cm}|
%     >{\raggedright\arraybackslash}X|
%     >{\raggedright\arraybackslash}X|
%     >{\raggedright\arraybackslash}X|}

%     \hline
%     \rowcolor{gray!30}

\begin{table}[!t]
\small
  \centering
  \renewcommand{\arraystretch}{1.3}
  \rowcolors{2}{gray!10}{white}
  \captionsetup{justification=centering}
  \caption{Timeline of Key Agent Interoperability Milestones}
  \label{tab:timeline}
  
  \begin{tabularx}{\textwidth}{|
    >{\centering\arraybackslash}p{1.5cm}|
    >{\raggedright\arraybackslash}p{2.5cm}|
    >{\raggedright\arraybackslash}X|}
    \hline
    \rowcolor{gray!30}
  % {p{1.5cm} p{4cm} p{7cm}}
    % \toprule
    \textbf{Year} & \textbf{Milestone} & \textbf{Key Contribution} \\
     \hline
    % \midrule
    1993 & KQML & Introduced speech-act primitives and a flexible message envelope for knowledge-based agents~\cite{genesereth1993kqml}. \\
    1998 & MASIF & Defined basic service registration and discovery mechanisms for agent environments~\cite{pitt1998masif}. \\
    2000 & FIPA-ACL & Standardized performative semantics, content languages, and interaction protocols with formal pre-/post-conditions~\cite{fipa2000acl}. \\
    2002 & Web Services (SOAP/WSDL) & Enabled service-oriented agent integration via UDDI, XML messaging, and contract definitions~\cite{curbera2002web}. \\
    2006 & ESB Patterns & Codified enterprise integration patterns (routing, transformation) in ESBs like Apache Camel and Mule~\cite{hohpe2006enterprise}. \\
    2020 & RAG & Coupled dense vector retrieval with LLM decoding to ground outputs in external corpora~\cite{lewis2020rag}. \\
    2023 & Function Calling & Allowed LLMs to emit JSON-formatted API calls against a catalog of function schemas~\cite{openai2023function}. \\
    2023 & Toolformer & Trained LLMs via self-supervised masking to predict API call placement in text~\cite{le2023toolformer}. \\
    2023 & ReAct & Interleaved chain-of-thought reasoning and explicit action calls for dynamic workflows~\cite{yao2023react}. \\
    2024 & MCP & Proposed a JSON-RPC protocol for standardized context ingestion and tool invocation~\cite{mcp2024introduction}. \\
     2024 & ANP & Peer-to-peer protocol enabling cross-platform and cross-organization agent communication over the open internet.~\cite{anp2024github}. \\
    2024 & ACP & Defined performative messaging primitives with formal types and security layers~\cite{beeai2024acp}. \\
    2025 & A2A & Introduced peer discovery, capability exchange, and decentralized agent dialogues~\cite{google2024a2a}. \\
    \bottomrule
  \end{tabularx}
\end{table}

\begin{figure}
    \centering
    \includegraphics[width=0.4\linewidth]{timeline_agent.png}
    \caption{Timeline of Interoperability}
    \label{fig:timeline}
\end{figure}


% Referencing the visual figure clearly first
% Figure~\ref{fig:timeline} illustrates the evolutionary trajectory of agent interoperability standards in a visually intuitive manner. The tree structure metaphorically represents how foundational protocols branched into more specialized and advanced interoperability standards over time, showcasing both linear progression and parallel innovation.

% Clear reference to the detailed table and its role
% To accompany the visual timeline, Table~\ref{tab:timeline} offers additional technical depth by explicitly listing each milestone alongside  precise descriptions of contributions and corresponding references. This tabular format allows readers to trace the chronological progression and understand the precise advancements that each milestone introduced to the agent interoperability landscape.

% Together, the figure and table clearly illustrate three distinct evolutionary phases:

Three distinct evolutionary phases emerge:

\begin{enumerate}
    \item \textbf{Symbolic and SOA Foundations (1993–2006):} Early interoperability standards such as KQML and FIPA-ACL set formal semantic foundations. Subsequent developments in Web Services and Enterprise Service Bus (ESB) frameworks streamlined enterprise integration but introduced complexity and limited flexibility.
    
    \item \textbf{Retrieval and In-Model Action (2020–2023):} Marked by the introduction of Retrieval-Augmented Generation (RAG), this phase leveraged vector-based retrieval to enhance the grounding of language model outputs. Innovations like Function Calling, Toolformer, and ReAct enabled LLMs to directly translate reasoning into executable API calls, significantly advancing agent autonomy and flexibility.
    
    \item \textbf{Protocol-Oriented Interoperability (2024–2025):} The current phase emphasizes lightweight, standardized protocols such as MCP, ACP, ANP, and A2A. These protocols address previous limitations by enabling dynamic discovery, secure communication, and decentralized collaboration across heterogeneous agent systems, promoting scalability and robust interoperability.
\end{enumerate}

% The combination of visual and tabular representations offers comprehensive historical context and clarifies the significance of each evolutionary phase, framing the rationale for emerging protocol standards within the broader trajectory of agent system development.






% \subsection{Summary and Motivation}
% \label{sec:summary}

% Our historical survey—from early symbolic ACLs (KQML, FIPA-ACL) through service-oriented ESBs and Retrieval-Augmented Generation (RAG) to modern function-calling and lightweight orchestration frameworks—reveals a persistent fragmentation: while each innovation addresses part of the interoperability puzzle, {\em no unified, protocol-level standard} governs how agents share context, negotiate capabilities, and coordinate actions across heterogeneous environments~\cite{genesereth1993kqml,fipa2000acl,curbera2002web,lewis2020rag,bommasani2021opportunities}.

% Symbolic ACLs provided well-defined performatives and content languages but suffered from heavyweight tooling and limited industry uptake. Service-oriented architectures and ESBs decoupled service producers and consumers yet led to brittle adapters and configuration sprawl~\cite{hohpe2006enterprise}. RAG grounded LLM outputs in external data but treated retrieval and action as separate, batch processes~\cite{lewis2020rag}. Function calling unified natural language understanding with API invocation, yet relies on static tool catalogs and lacks dynamic discovery~\cite{openai2023function}. Lightweight frameworks such as Toolformer and ReAct demonstrate tight reasoning-action loops but operate in siloed ecosystems with bespoke metadata and security models~\cite{le2023toolformer,yao2023react,liu2024autotool}.

% To address these gaps, we propose three complementary, protocol-level standards:

% \begin{enumerate}
%   \item \textbf{Model Context Protocol (MCP)}—A JSON-RPC schema for ingesting shared context and invoking tools in a uniform manner~\cite{mcp2024introduction}.
%   \item \textbf{Agent Communication Protocol (ACP)}—A performative messaging layer with formal type systems, pre-/post-condition semantics, and built-in security primitives for authenticated exchanges~\cite{beeai2024acp}.
%   \item \textbf{Agent2Agent Protocol (A2A)}—A decentralized discovery and negotiation framework using JSON-RPC and publish/subscribe patterns to enable dynamic capability advertising, peer discovery, and multi-agent dialogue~\cite{google2024a2a,sheriff2024dynamic}.
% \end{enumerate}

% We examine each protocol’s architecture, core primitives, and security model in depth; we then present a comparative analysis of their trade-offs and outline a phased adoption roadmap aimed at driving convergence toward secure, composable, and scalable LLM-driven agent ecosystems.







\section{MCP}

\subsection{Client Application (Host)}
The \textbf{Client Application (Host)} serves as the initiator of interactions in the MCP ecosystem. It is responsible for managing connections to one or more MCP Servers and orchestrating communication workflows in accordance with protocol specifications. In practice, the client initializes sessions, requests and processes the four core primitives \textit{Resources}, \textit{Tools}, \textit{Prompts}, and \textit{Sampling}, and handles asynchronous notifications related to server-side events. The client must also implement robust error-handling routines to gracefully manage communication failures or timeout conditions, ensuring reliable coordination with remote MCP Servers.

% \begin{figure}
%     \centerline
%     \includegraphics{mcp.png}
%     \caption{An overview of MCP~\cite{singh2025mcp}}
%     \label{fig:MCP}
% \end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{mcp.png}
    \caption{An overview of MCP~\cite{singh2025mcp}}
    \label{fig:MCP}
\end{figure}

\subsection{MCP Server (Providing Context \& Capabilities)}
The \textbf{MCP Server} functions as the provider of data, services, and interaction templates that the client can utilize to enrich LLM-based workflows. It exposes and manages contextual \textit{Resources}, executes external operations via \textit{Tools}, defines reusable \textit{Prompts} for consistent interaction patterns, and optionally delegates text-generation tasks through \textit{Sampling}. Beyond serving requests, the server is responsible for enforcing access control policies, maintaining operational security, and emitting notifications that reflect changes in its available capabilities. This provider-side architecture complements the client’s orchestration logic by modularizing access to complex or dynamic resources.

\subsection{Core Components}
The Model Context Protocol is composed of several layered abstractions that govern the structure and semantics of communication. At the foundation lies the \textbf{Protocol Layer}, which defines the semantics of message exchange using the JSON-RPC 2.0 specification. It ensures that each request is linked to a corresponding response and that all interactions conform to predictable patterns. Above this, the \textbf{Transport Layer} handles the physical transmission of messages between the client and server, supporting both local communication via \texttt{Stdio} and network-based channels such as \texttt{HTTP} with optional Server-Sent Events (SSE). At the highest abstraction, MCP organizes messages into four types: \textbf{Requests}, which are calls expecting replies; \textbf{Results}, which are successful responses to earlier requests; and \textbf{Errors}, which indicate failures or invalid invocations. A fourth type, \textbf{Notifications}, is used for asynchronous updates that do not require a client acknowledgment.


\subsection{MCP Server Core Capabilities}

The MCP Server offers four core capabilities \textbf{Tools}, \textbf{Resources}, \textbf{Prompts}, and \textbf{Sampling} each mapped to a distinct control model that governs the interaction between the client, the server, and the LLM. 

\textbf{Tools} are model-controlled capabilities that allow the LLM to invoke external APIs or services, often automatically and sometimes with user approval. This facilitates seamless integration with third-party systems and streamlines access to real-world data and operations. 

\textbf{Resources} are application-controlled elements, such as structured documents or contextual datasets, that are selected and managed by the client application. They provide the LLM with tailored, task-specific inputs and enable context-aware completions. 

\textbf{Prompts} are user-controlled templates defined by the server but selected by end-users through the client interface. These reusable prompts promote consistency, reduce redundancy, and support repeatable interaction patterns.

\textbf{Sampling} is server-controlled and allows the MCP Server to delegate the task of generating LLM completions to the client. This supports sophisticated agentic workflows and enables fine-grained oversight over the model’s generative process, including the ability to adjust temperature, length, and other sampling parameters dynamically.

\subsection{MCP Connection Lifecycle}

The Model Context Protocol (MCP) defines a three-phase lifecycle for client–server interactions, designed to ensure robust session management, secure capability negotiation, and clean termination. These phases \textbf{Initialization}, \textbf{Operation}, and \textbf{Shutdown} correspond to the temporal sequence of communication between the Client Application and MCP Server.

\textbf{Initialization} begins by establishing protocol compatibility and exchanging supported capabilities. During version negotiation, the client and server agree on the highest mutually supported protocol version. This is followed by a capability exchange, in which both sides advertise optional features—such as sampling, prompts, tools, and logging—that can be used during the session. The phase concludes with a \texttt{notifications/initialized} message sent by the client after receiving the server’s \texttt{initialize} response, signaling readiness to proceed to operational communication.

\textbf{Operation} represents the core active phase, during which the client and server exchange JSON-RPC method calls and notifications in accordance with the negotiated capabilities. Both parties are expected to adhere strictly to the features agreed upon during initialization, ensuring compatibility and predictability. Each task invocation may include a configurable timeout, and if a response is not received within that window, the client may issue a cancellation notification to prevent resource exhaustion or stale execution threads.

\textbf{Shutdown} ensures a clean and predictable end to the session. Either party may initiate termination by closing the transport layer typically HTTP or stdio which signals the end of communication. Upon shutdown, both client and server are responsible for resource cleanup, including the removal of active timeouts, cancellation of subscriptions, and deallocation of any spawned child processes. After this point, no new protocol messages should be sent, with the exception of essential diagnostics like ping or log flush events.

\subsection{Security Challenges and Mitigations Across the MCP Lifecycle}
As MCP adoption increases in enterprise and developer ecosystems, its lifecycle introduces multiple security vulnerabilities spanning initialization, operation, and update phases. These risks include tool poisoning, privilege persistence, and command injection, among others, many of which are amplified by LLMs’ susceptibility to prompt manipulation and opaque execution traces. 

Table~\ref{tab:mcp-threats} summarizes the most critical security threats identified across each lifecycle phase of MCP deployments, alongside their corresponding mitigation strategies and authoritative references. This synthesis reflects both current attack disclosures and best-practice defenses from recent audits and protocol reviews.

% \begin{table}[h]
%   \centering
%   \renewcommand{\arraystretch}{1.25}
%   \rowcolors{2}{gray!15}{white}
%   \captionsetup{justification=centering,aboveskip=5pt,belowskip=5pt}
%   \caption{Threats and Mitigations Across the MCP Lifecycle}
%   \label{tab:mcp-merged-threats}
%   \begin{tabularx}{\linewidth}{|
%       >{\centering\arraybackslash}p{2cm}|
%       >{\raggedright\arraybackslash}p{3.2cm}|
%       >{\raggedright\arraybackslash}p{4.2cm}|
%       >{\raggedright\arraybackslash}p{4.6cm}|}
%     \toprule
%     \rowcolor{gray!30}
%     \textbf{Phase} & \textbf{Threat} & \textbf{Description} & \textbf{Mitigation Strategy (with Reference)} \\
%     \midrule

%     \textbf{Creation} 
%     & Installer Spoofing 
%     & Malicious MCP packages inserted during build or installation pipelines.
%     & Enforce SBOMs, digital signatures, and SLSA-compliant reproducible builds~\cite{equixly2025, slowmist2025}. \\

%     \cline{2-4}
%     & Supply-Chain Backdoors 
%     & Persistent malware introduced through tampered CI/CD artifacts.
%     & Harden CI/CD using SLSA, manifest validation, and artifact integrity checks~\cite{narajala2025}. \\

%     \cline{2-4}
%     & Name Collision 
%     & Adversaries impersonate trusted MCP agents using similar names.
%     & Use Sigstore-backed namespace signing and enforce DIDs for unique identity~\cite{hou2025modelcontextprotocolmcp}. \\

%     \cline{2-4}
%     & No Auth Handshake 
%     & Clients connect to unauthenticated servers, enabling tool abuse.
%     & Require mutual authentication with DIDs, token headers, and TLS validation~\cite{narajala2025}. \\

%     \midrule

%     \textbf{Operation} 
%     & Tool Poisoning 
%     & Hidden malicious prompts or metadata exploit LLM behavior.
%     & Apply strict schema validation, YARA/RegEx rules, and deep semantic filtering~\cite{narajala2025, radosevich2025}. \\

%     \cline{2-4}
%     & Credential Theft 
%     & Secrets exfiltrated via coerced completions or tool output.
%     & Use OAuth 2.1 + PKCE, limit token scopes, and enforce mTLS transport~\cite{radosevich2025, phala2025}. \\

%     \cline{2-4}
%     & Sandbox Escape 
%     & Tools escape isolation and access host or OS-level services.
%     & Harden environments using seccomp, AppArmor, syscall filters, and microsegmentation~\cite{equixly2025}. \\

%     \cline{2-4}
%     & Remote Access Control (RAC) 
%     & LLM behavior injects SSH keys or creates reverse shells.
%     & Deploy host-based EDR/HIDS and monitor for behavioral anomalies~\cite{radosevich2025}. \\

%     \cline{2-4}
%     & Command Injection / RCE 
%     & Unsafe strings lead to system-level execution via shell expansion.
%     & Sanitize inputs, disable shell invocation, and enforce no-eval policies~\cite{evren2025}. \\

%     \cline{2-4}
%     & Tool Redefinition (Rug Pull) 
%     & Tools mutate from benign to malicious after initial validation.
%     & Require signed, version-pinned manifests with diffs and policy gates~\cite{cross2025}. \\

%     \cline{2-4}
%     & Cross-Server Shadowing 
%     & One MCP server hijacks or overrides another’s tool references.
%     & Validate source signature on tool routing and enforce scoped namespaces~\cite{cross2025}. \\

%     \cline{2-4}
%     & Lack of Visibility 
%     & Tool prompts or instructions hidden from client audit.
%     & Provide full debug views, manifest introspection, and metadata logging~\cite{cross2025}. \\

%     \midrule

%     \textbf{Update} 
%     & Version Drift 
%     & Old MCP servers with known CVEs continue operating.
%     & Enforce version pinning, GitOps drift detection, and auto-remediation~\cite{microsoft2025}. \\

%     \cline{2-4}
%     & Privilege Persistence 
%     & Updates retain old elevated roles or token scopes.
%     & Audit tokens/roles post-update and apply key rotation policies~\cite{narajala2025}. \\

%     \cline{2-4}
%     & Configuration Drift 
%     & Post-update misconfigs expose new vulnerabilities.
%     & Validate config with known CVEs, WAF/IDPS filtering, and hardened defaults~\cite{narajala2025}. \\

%     \cline{2-4}
%     & Unsigned Tool Manifests 
%     & Metadata is modified or tampered without detection post-update.
%     & Enforce manifest signing at boot and prohibit unsigned tool use~\cite{phala2025}. \\

%     \bottomrule
%   \end{tabularx}
% \end{table}


\begin{table}[ht]
  \centering
  \renewcommand{\arraystretch}{1.2}
  \rowcolors{2}{gray!10}{white}
  \captionsetup{justification=centering}
  \caption{Threats and Mitigation Strategies Across the MCP Lifecycle}
  \label{tab:mcp-threats}
\begin{tabularx}{\textwidth}{|
    >{\centering\arraybackslash}p{2.1cm}|
    >{\raggedright\arraybackslash}X|
    >{\raggedright\arraybackslash}X|
    >{\raggedright\arraybackslash}X|}

    \hline
    \rowcolor{gray!30}
    \textbf{Phase} & \textbf{Threat} & \textbf{Description} & \textbf{Mitigation Strategy} \\
    \hline

    \textbf{Creation} 
    & Installer Spoofing 
    & Malicious packages introduced during build or install pipelines.
    & Enforce SBOMs, digital signatures, and reproducible builds. \\

    & Supply-Chain Backdoors 
    & Persistent malware via CI/CD artifacts.
    & Harden CI/CD, validate manifests, and verify artifact integrity. \\

    & Name Collision 
    & Impersonation of trusted MCP agents using similar names.
    & Use Sigstore and DIDs to ensure unique, verifiable identities. \\

    & No Auth Handshake 
    & Clients connect to unauthenticated or rogue servers.
    & Enforce mutual authentication and TLS-based validation. \\

    \hline

    \textbf{Operation} 
    & Tool Poisoning 
    & Malicious prompts or metadata influencing LLM behavior.
    & Validate schemas, use filtering (YARA/RegEx), and apply semantic guards. \\

    & Credential Theft 
    & Secrets leaked via completions or tool output.
    & Use OAuth 2.1 + PKCE, restrict token scopes, and enforce mTLS. \\

    & Sandbox Escape 
    & Tools access host OS or bypass isolation.
    & Use syscall filters, AppArmor, and container hardening. \\

    & Remote Access Control 
    & LLMs inject SSH keys or create backdoor shells.
    & Monitor with EDR/HIDS and restrict outbound behavior. \\

    & Command Injection / RCE 
    & Unsafe inputs trigger system execution.
    & Sanitize inputs, disable shell access, and disallow evals. \\

    & Tool Redefinition 
    & Tools turn malicious after validation ("rug pull").
    & Use signed, versioned manifests and monitor for mutation. \\

    & Cross-Server Shadowing 
    & One server overrides another’s tool references.
    & Enforce scoped namespaces and validate routing origins. \\

    & Lack of Visibility 
    & Clients cannot inspect tool instructions or payloads.
    & Enable debug mode, metadata introspection, and logging. \\

    \hline

    \textbf{Update} 
    & Version Drift 
    & Older vulnerable MCP versions remain in use.
    & Use GitOps for drift detection and enforce auto-remediation. \\

    & Privilege Persistence 
    & Retained elevated roles or old token scopes.
    & Audit roles after updates and rotate credentials. \\

    & Configuration Drift 
    & Misconfigurations introduced post-update.
    & Validate against CVEs and apply hardened defaults. \\

    & Unsigned Tool Manifests 
    & Manifests altered or injected post-deployment.
    & Enforce signature checks and block unsigned tools. \\

    \hline
  \end{tabularx}
\end{table}




% \section{Model Context Protocol (MCP) Architecture}

% The Model Context Protocol enables applications to extend Large Language Model (LLM) capabilities by invoking external data and functionality via a JSON-RPC-based client–server standard. Communication occurs between two endpoints:

% \subsection{MCP Architecture Components}
% \textbf{Client Application (Host)} and \textbf{MCP Server} share the following responsibilities:

% \begin{tabularx}{\linewidth}{lX}
% \toprule
% \bfseries Task & \bfseries Client Application (Host) \\ 
% \midrule
% Connection Management & Establish and maintain JSON-RPC sessions (HTTP or stdio); handle errors and retries. \\
% Capability Requests    & Request Tools, Resources, Prompts, and Sampling operations. \\
% Notifications          & Process asynchronous server notifications (e.g., context updates). \\
% \midrule
% \bfseries Task & \bfseries MCP Server \\ 
% \midrule
% Capability Exposure     & Advertise and serve Resources, Tools, and Prompts; accept Sampling requests. \\
% Security Enforcement    & Authenticate clients; authorize access to each capability. \\
% Notification Emission   & Send events on resource changes or new tool availability. \\
% \bottomrule
% \end{tabularx}

% \subsection{Core Layers and Semantics}
% MCP relies on three foundational layers:

% \begin{itemize}[leftmargin=*]
%   \item \textbf{Protocol Layer}: Defines JSON-RPC 2.0 methods for \emph{initialize}, capability exchange, invoke, and shutdown.  
%   \item \textbf{Transport Layer}: Supports stdio or HTTP(S) with optional Server-Sent Events (SSE) to carry JSON-RPC messages.  
%   \item \textbf{Message Semantics}: Four message types—\texttt{Request}, \texttt{Result}, \texttt{Error}, and \texttt{Notification}—ensure clear interactions.
% \end{itemize}

% \subsection{Core Capabilities}


% The MCP Server offers four primitives that shape LLM-driven workflows. Each primitive corresponds to a distinct control model:

% \begin{table}[h]
%   \centering
%   \renewcommand{\arraystretch}{1.2}
%   \caption{MCP Server Core Capabilities}
%   \label{tab:mcp-core-capabilities}
%   \begin{tabularx}{\linewidth}{lXl}
%     \toprule
%     \bfseries Capability & \bfseries Description & \bfseries Control Model \\
%     \midrule
%     Tools      & Invocation of external APIs or services automatically by the LLM.       & Model-driven \\
%     Resources  & Provision of contextual data fetched by the client for LLM input.        & Application-driven \\
%     Prompts    & Reusable interaction templates selected by end-users via the client.     & User-driven \\
%     Sampling   & Server-initiated delegation of LLM completion generation to the client.  & Server-driven \\
%     \bottomrule
%   \end{tabularx}
% \end{table}
% \begin{figure}
%     \centering
%     \includegraphics[width=0.5\linewidth]{LLM Workflow Management Overview.png}
%     \caption{MCP Core Capabilities}
%     \label{fig:corecapabilities}
% \end{figure}
% \subsection{MCP Connection Lifecycle}
% \begin{description}[leftmargin=1em]
%   \item[\textbf{Initialization}] Version negotiation, capability exchange, and ready notification~\cite{mcp2024spec}.
%   \item[\textbf{Operation}] JSON-RPC calls and notifications per agreed features; timeouts and cancellations enforce limits.
%   \item[\textbf{Shutdown}] Graceful transport closure and resource cleanup; no new messages except essential pings.
% \end{description}



% \subsection{Security Challenges and Mitigations Across the MCP Lifecycle}

% A consolidated view of principal threats and key mitigations for each phase of the MCP connection lifecycle is provided in Table~\ref{tab:mcp-security}.

% \begin{table}[h]
%   \centering
%   \renewcommand{\arraystretch}{1.2}
%   \rowcolors{2}{gray!15}{white}
%   \captionsetup{justification=centering,aboveskip=5pt,belowskip=5pt}
%   \caption{MCP Lifecycle Threats and Key Mitigations}
%   \label{tab:mcp-security}
%   \begin{tabularx}{\linewidth}{|
%       >{\centering\arraybackslash}p{2.0cm}|
%       >{\raggedright\arraybackslash}X|
%       >{\raggedright\arraybackslash}X|
%       >{\centering\arraybackslash}p{2.5cm}|}
%     \toprule
%     \rowcolor{gray!30}
%     \textbf{Phase} & \textbf{Threat} & \textbf{Key Mitigation} & \textbf{Reference} \\
%     \midrule
%     \textbf{Initialization}
%       & Installer spoofing / supply-chain backdoors  
%       & SBOM verification, Sigstore signing, SLSA-compliant CI/CD  
%       & \cite{equixly2025, narajala2025, slowmist2025} \\
%     \cline{2-4}
%       & Name collision / no auth handshake  
%       & Enforce DID-based authentication; cryptographic namespace validation  
%       & \cite{hou2025, narajala2025} \\
%     \midrule
%     \textbf{Operation}
%       & Tool poisoning / malicious code execution  
%       & Schema validation, deep-semantic scanning, sandboxing (seccomp/AppArmor)  
%       & \cite{narajala2025, radosevich2025} \\
%     \cline{2-4}
%       & Credential theft / data exfiltration / remote access control  
%       & mTLS, OAuth 2.1 + PKCE, scoped tokens, EDR/HIDS monitoring  
%       & \cite{narajala2025, equixly2025} \\
%     \cline{2-4}
%       & Sandbox escape / cross-server shadowing  
%       & Process isolation, microsegmentation, transport hardening  
%       & \cite{equixly2025, cross2025} \\
%     \cline{2-4}
%       & Command Injection & RCE / over-broad permissions  
%       & Input sanitization, least-privilege scopes, audit logging  
%       & \cite{evren2025, phala2025} \\
%     \midrule
%     \textbf{Shutdown/Update}
%       & Version drift / privilege persistence  
%       & GitOps drift detection, version pinning, post-update audits  
%       & \cite{microsoft2025, narajala2025} \\
%     \bottomrule
%   \end{tabularx}
% \end{table}

% \section{Agent-to-Agent Protocol (A2A) Architecture}

% The Agent-to-Agent Protocol (A2A) defines a peer-to-peer framework for dynamic discovery, task orchestration, and artifact exchange among autonomous agents using structured “Agent Cards” and HTTP(S) transports~\cite{google2024a2a}.

% \subsection{Component Roles and Responsibilities}
% Table~\ref{tab:a2a-roles} summarizes the three primary A2A participants and their core duties.

% \begin{table}[h]
%   \centering
%   \renewcommand{\arraystretch}{1.2}
%   \caption{A2A Component Roles and Responsibilities}
%   \label{tab:a2a-roles}
%   \begin{tabularx}{\linewidth}{lX}
%     \toprule
%     \bfseries Role & \bfseries Responsibilities \\
%     \midrule
%     \emph{User} 
%       & Originates tasks or requests; may be a human, service, or higher-level agent. \\
%     \midrule
%     \emph{Client Agent} 
%       & Discovers Remote Agents via Agent Cards; constructs and sends Task objects; manages session context; handles Artifacts, notifications, and errors. \\
%     \midrule
%     \emph{Remote Agent (Server)} 
%       & Advertises capabilities in Agent Cards; processes Task requests (\texttt{runTask}); generates and returns Artifacts; emits optional streaming updates (SSE/webhooks). \\
%     \bottomrule
%   \end{tabularx}
% \end{table}

% \subsection{Core Layers and Semantics}
% A2A communication rests on three foundational elements:

% \begin{itemize}[leftmargin=*]
%   \item \textbf{Protocol Layer}: JSON-RPC 2.0 methods such as \texttt{getAgentCard}, \texttt{runTask}, and notifications.
%   \item \textbf{Transport Layer}: HTTP(S) request/response with optional Server-Sent Events (SSE) or webhooks for real-time updates.
%   \item \textbf{Message Semantics}: Structured payloads containing Task parameters, context, and metadata; Artifacts include results, files, or status messages.
% \end{itemize}

% \subsection{Core Capabilities}
% A2A exposes two main primitives that drive multi-agent workflows:

% \begin{table}[h]
%   \centering
%   \renewcommand{\arraystretch}{1.2}
%   \caption{A2A Core Capabilities}
%   \label{tab:a2a-capabilities}
%   \begin{tabularx}{\linewidth}{lX}
%     \toprule
%     \bfseries Capability & \bfseries Description \\
%     \midrule
%     Agent Cards 
%       & JSON-based manifests declaring an agent’s identity, skills, endpoint, and security metadata for discovery. \\
%     \midrule
%     Task \& Artifact Exchange 
%       & Peer-to-peer invocation of \texttt{runTask} with structured inputs and receipt of Artifacts (results, files, streaming updates). \\
%     \bottomrule
%   \end{tabularx}
% \end{table}

% \subsection{A2A Connection Lifecycle}
% The A2A protocol proceeds through three phases:

% \begin{description}[leftmargin=1em]
%   \item[\textbf{Discovery}] Client Agent retrieves Agent Cards via HTTP GET or registry API.
%   \item[\textbf{Execution}] Client Agent issues \texttt{runTask} RPC; Remote Agent executes the task and returns Artifacts; optional real-time updates via SSE/webhooks.
%   \item[\textbf{Termination}] Client Agent closes connections; both sides clean up session state.
% \end{description}




% \section{A2A Architecture}
% The Agent-to-Agent (A2A) architecture facilitates communication and collaboration between different agentic systems to accomplish tasks. It comprises three primary actors that interact through a defined protocol to enable seamless and secure operation.

% \subsection{Core Components}
% The A2A architecture includes three core actors: \textit{User}, \textit{Client Agent}, and \textit{Remote Agent (Server)}. These components collaborate to allow users to leverage the capabilities of specialized agents. In a typical workflow:
% \begin{itemize}
%     \item The \textbf{User} initiates a task or request.
%     \item The \textbf{Client Agent} receives this request, analyzes the intent, and identifies a suitable \textbf{Remote Agent (Server)} based on its advertised capabilities via the Agent Card.
%     \item The Client Agent communicates with the selected Remote Agent to execute the task, exchanging messages and receiving results (termed \textit{Artifacts}), which are then presented to the User.
% \end{itemize}

% \subsection{User}
% The \textbf{User} is the entity that initiates the interaction with the agent system. This entity possesses a need or intent for a specific task to be executed. While commonly a human end-user, the User may also be a software system, service, or automated process. Within the A2A protocol, the User is recognized as the originator of any agent-based interaction.

% In essence, the User is the source of the original request that triggers the entire A2A workflow. The User does not interact directly with the Remote Agent; instead, the communication occurs through the Client Agent, which operates on the User’s behalf.

% \subsubsection{User Roles and Interaction Models}
% The A2A protocol accommodates various User types and interaction paradigms, including:

% \begin{itemize}
%     \item \textbf{Direct End-User:} A human user interacting directly with a Client application, such as a chatbot, web interface, or voice assistant. The User provides input, receives output, and may guide the flow of execution.
    
%     \item \textbf{Indirect End-User:} A human user engaging with a higher-level system that leverages A2A agents in the background to execute sub-tasks. For example, enterprise software may use agentic services transparently.
    
%     \item \textbf{System or Service:} An automated system initiating tasks through A2A interactions. Examples include business process management tools or data pipelines that invoke agents for transformation or analysis tasks.
    
%     \item \textbf{Agent as User:} In hierarchical or multi-agent systems, one agent may serve as a User by initiating tasks toward another agent to fulfill broader goals or enable delegation.
% \end{itemize}

% The A2A protocol is agnostic to the nature of the User. Its primary focus is the standardization of communication between the Client Agent and the Remote Agent, enabling interoperability across a wide variety of applications regardless of the User’s form. This design supports flexible integration of A2A into diverse workflows and environments.



% \subsection{Client Agent}
% The \textbf{Client Agent} is a software entity that acts on behalf of the User to interact with Remote Agents. It serves as an intermediary, translating User requests into a format that Remote Agents can interpret and processing their responses before presenting them to the User. The Client Agent is responsible for orchestrating interactions with one or more Remote Agents to fulfill the User’s task objectives.

% \subsubsection{Client Responsibilities}
% Within the A2A architecture, the Client Agent undertakes several critical responsibilities:

% \begin{itemize}
%     \item \textbf{Agent Discovery:} The Client Agent uses the Agent Card mechanism to discover suitable Remote Agents that possess the capabilities required to fulfill the User’s task. This involves retrieving and parsing Agent Cards, then selecting the most appropriate agent based on advertised skills, service-level agreements, or additional criteria.
    
%     \item \textbf{Task Initiation:} The Client Agent constructs a Task object representing the User's request and sends it to the chosen Remote Agent. This includes formatting input into a structured Message, initializing the Task state, and attaching relevant metadata.
    
%     \item \textbf{Message and Artifact Exchange:} The Client Agent engages in bi-directional communication with the Remote Agent through Messages. These may include instructions or queries sent by the Client Agent, and status updates or additional requests sent by the Remote Agent. The Client also receives Artifacts—the tangible outputs of task execution—from the Remote Agent.
    
%     \item \textbf{Session Management:} If the use case requires, the Client Agent maintains session context using identifiers to group related Tasks. This supports more complex and stateful interactions across multiple exchanges.
    
%     \item \textbf{Error Handling:} The Client Agent is responsible for managing errors that may occur during interaction with the Remote Agent. These could arise from malformed requests, agent failures, or authorization issues. The Client Agent must parse error responses and take corrective actions such as retrying, selecting an alternate agent, or notifying the User.
    
%     \item \textbf{Result Presentation:} Once Artifacts are received, the Client Agent processes and transforms them into user-friendly formats, integrating them into the surrounding application logic or UI as needed.
    
%     \item \textbf{Asynchronous Communication (Optional):} 
%     \begin{itemize}
%         \item \textit{SSE Handling:} If the Remote Agent supports Server-Sent Events (SSE), the Client Agent establishes and manages the persistent connection, processes streaming updates, and updates the application in real-time.
%         \item \textit{Push Notification Handling:} If Push Notification support is implemented, the Client Agent registers with the notification service and processes asynchronous task updates delivered out-of-band by the Remote Agent.
%     \end{itemize}
% \end{itemize}


% The Client Agent serves as the critical bridge between Users and Remote Agents, enabling intelligent coordination, dynamic task management, and seamless delivery of outcomes across the A2A protocol.






% \subsection{Remote Agent (Server)}
% The \textbf{Remote Agent (Server)} is a software entity that offers specific capabilities or skills to Clients. Functioning as a service provider, it receives requests from Clients, processes those requests, and returns the corresponding results. The Remote Agent is responsible for managing its computational resources, enforcing security policies, and maintaining the state of ongoing tasks throughout their lifecycle.

% \subsubsection{Remote Agent Capabilities and Skills Management}
% The core functionality of a Remote Agent lies in the provision and management of specialized skills. These can span a range of complexity—from simple data retrieval to advanced computation or orchestration involving external systems. To make these capabilities usable, the Remote Agent must advertise and manage them effectively:

% \begin{itemize}
%     \item \textbf{Skill Definition:} Skills are discrete functions or operations that the Remote Agent can perform. Each skill is defined by its expected input parameters and output format, enabling predictable interaction.

%     \item \textbf{Agent Card Publication:} The Remote Agent publishes an \textit{Agent Card}—a structured metadata document that enumerates its available skills, input/output requirements, authentication expectations, and endpoint details.

%     \item \textbf{Capability Advertisement:} The Agent Card serves as the primary advertisement mechanism, allowing Clients to discover the agent’s offerings and determine how to interact with them.

%     \item \textbf{Resource Management:} Execution of skills may consume various resources including CPU, memory, storage, and network bandwidth. The Remote Agent is responsible for managing and optimizing resource usage.

%     \item \textbf{Security:} The Remote Agent enforces security protocols to regulate access to its skills and safeguard its infrastructure. This includes authentication of Clients and fine-grained authorization mechanisms to restrict access based on defined policies.


% The Remote Agent operates as the service endpoint in the A2A protocol, executing tasks delegated by Clients and enabling modular, interoperable agentic ecosystems.

\section{A2A Architecture}
The Agent-to-Agent (A2A) architecture facilitates communication and collaboration between distinct agentic systems to accomplish tasks. It comprises three primary actors—\textit{User}, \textit{Client Agent}, and \textit{Remote Agent (Server)}, that interact via a well-defined protocol, enabling secure and interoperable execution.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{a2a.png}
    % \includesvg[width=\linewidth]{a2a.svg}
    \caption{An overview of A2A}
    \label{fig:A2A}
\end{figure}


\subsection{Core Components}
The \textbf{User} initiates a task or request, typically without needing to understand or directly interact with the underlying agentic systems. The \textbf{Client Agent} receives this request, analyzes its intent, and identifies a suitable \textbf{Remote Agent (Server)} by inspecting the advertised capabilities through its Agent Card. Once selected, the Client Agent engages the Remote Agent to execute the task, coordinating message exchanges and retrieving results—termed \textit{Artifacts}—which are then delivered back to the User.

\subsubsection{User}
The \textbf{User} acts as the originator of any A2A interaction, embodying the intent or need that sets the agentic process in motion. While frequently a human end-user, the User can also be a system, service, or another agent in hierarchical workflows. Regardless of its form, the User does not directly interact with Remote Agents; instead, it relies on the Client Agent to translate its requests into actionable tasks and to mediate all responses.

A2A supports diverse User interaction models. A \textbf{Direct End-User} may engage with the Client Agent through interfaces such as chatbots or voice assistants, providing task input and receiving results in real time. An \textbf{Indirect End-User} interacts with higher-level systems that transparently utilize A2A agents behind the scenes, such as enterprise dashboards or orchestration tools. \textbf{Systems or Services} may also act as Users, invoking A2A agents autonomously for workflows like data transformation or monitoring. In multi-agent hierarchies, an \textbf{Agent as User} scenario occurs when one agent triggers downstream actions by another agent to fulfill complex tasks. These various User paradigms underscore the protocol’s agnosticism toward User identity and emphasize its focus on standardizing communication between Client and Remote Agents.

\subsubsection{Client Agent}
The \textbf{Client Agent} serves as an intermediary that represents the User's intent and coordinates with Remote Agents to fulfill it. Its responsibilities span multiple stages of the task lifecycle. It begins by performing \textbf{Agent Discovery}, retrieving and evaluating Agent Cards that describe each Remote Agent’s skills, capabilities, input/output specifications, and authentication requirements. Based on this discovery, the Client selects a Remote Agent aligned with the User’s task. Next, the Client Agent is responsible for \textbf{Task Initiation}. It constructs a structured Task object, encapsulating the User's intent, relevant metadata, and formatted inputs. It then sends this task to the selected Remote Agent using a well-formed Message. During execution, the Client Agent manages the \textbf{Message and Artifact Exchange}. It communicates bi-directionally with the Remote Agent, sending new instructions or follow-ups, and receiving outputs—termed \textit{Artifacts}—along with any intermediate updates. For long-running or stateful interactions, it maintains \textbf{Session Context}, using identifiers to group related exchanges under a unified workflow.

The Client Agent also oversees \textbf{Error Handling}, parsing any failure responses returned by the Remote Agent, and executing appropriate recovery strategies such as retries, fallback agent selection, or User notifications. After execution, the \textbf{Result Presentation} step involves transforming Artifacts into a user-consumable format and integrating them into the surrounding application or user interface.

Where supported, the Client Agent may handle \textbf{Asynchronous Communication} through mechanisms such as Server-Sent Events (SSE) or push notifications. For SSE, it establishes a persistent connection and streams updates in real time. If push notification support is available, the Client Agent registers with a notification service to receive task updates delivered out-of-band. Altogether, the Client Agent acts as the execution orchestrator, data translator, and communication bridge within the A2A protocol, enabling intelligent, context-aware interactions on behalf of the User.

\subsubsection{Remote Agent (Server)}
The \textbf{Remote Agent (Server)} is the service endpoint that executes tasks delegated by the Client Agent. It provides one or more \textbf{Skills}, which represent discrete operations it can perform ranging from simple data retrieval to complex computations or orchestrations involving external APIs or databases. Each skill is formally defined by its input and output schema, enabling consistent invocation across clients.

To make these capabilities discoverable, the Remote Agent publishes an \textbf{Agent Card}—a structured metadata document that includes a list of available skills, usage instructions, input/output formats, supported protocols, and authentication requirements. This Agent Card acts as both an advertisement and an interface contract for interacting agents.

The Remote Agent must also manage its internal \textbf{Resource Usage}, ensuring fair allocation of compute, memory, network, and storage resources during task execution. Alongside execution, it is responsible for enforcing \textbf{Security and Access Control} mechanisms. This includes authenticating Clients, verifying message integrity, and authorizing access to specific skills based on access policies or token scopes. By abstracting service capabilities into modular, independently managed components, the Remote Agent supports composability, reliability, and interoperability within agentic ecosystems.

% \section{A2A  Main Components}
% An A2A agent is structured around several core objects that define its behavior, capabilities, and interactions. These components are essential for any agent to operate effectively within an A2A system. The following are the principal components and their roles:

% \begin{itemize}
%     \item \textbf{Agent Card: Self-description and discovery mechanism.} The Agent Card is a JSON-formatted document that publicly announces the agent’s existence and capabilities. It includes metadata such as the agent’s name, description, version, supported skills, and authentication methods. Clients use the Agent Card to discover and evaluate agents that can perform specific tasks. Without this component, an agent cannot be discovered or invoked by others, making it a fundamental entry point for interaction and coordination in A2A systems.

%     \item \textbf{Skills: Defining the agent’s capabilities.} Skills represent the specific functions or actions that an agent can perform. Each skill is described by its name, purpose, input parameters, and expected output format. These skills are invoked via Tasks and determine the utility and specialization of the agent. They are the core of what an agent offers, directly influencing its relevance and effectiveness within the A2A ecosystem.

%     \item \textbf{Task: The unit of delegated work.} A Task is the formal mechanism by which one agent requests another to perform a particular skill. It contains the name of the skill to be executed along with any necessary input parameters. Tasks are sent from a Client agent to a Remote Agent, which then processes the Task and returns results. Tasks encapsulate intention, enabling agents to cooperate asynchronously or synchronously to fulfill complex workflows.

%     \item \textbf{Message: The communication channel.} Messages are the primary vehicle for data exchange and coordination between agents. They may include instructions, updates, or payloads such as data, text, files, or references to Artifacts. Messages can consist of multiple parts and are used throughout the lifecycle of a Task—from initiation to result delivery. Effective messaging is critical for inter-agent interaction; without it, no operation or negotiation is possible.

%     \item \textbf{Artifact: Results from skill execution.} Artifacts are the outputs generated when a Remote Agent completes a Task. These may include structured data, files, links, or other material produced by skill execution. Artifacts are transmitted back to the Client agent, which may then relay the result to the User or further process it. Artifacts embody the tangible outcome of agent collaboration, allowing knowledge, data, and computation to be shared across systems.
% \end{itemize}


\subsection{A2A Main Components}

An A2A agent is structured around several core components that define its behavior, capabilities, and interactions. These components serve as the operational and semantic building blocks for any agent to function within an agent-to-agent ecosystem.

 \textbf{Agent Card} acts as a self-description and discovery mechanism. It is a JSON-formatted document that publicly declares the agent’s metadata, including its name, version, description, supported skills, and authentication requirements. Client Agents rely on Agent Cards to discover and evaluate Remote Agents that can fulfill specific task criteria. As the primary entry point for coordination, an agent without an Agent Card is effectively invisible within the A2A system.

\textbf{Skills} represent the actionable capabilities offered by an agent. Each skill is described by a name, purpose, expected input parameters, and output format. Skills are invoked via Tasks and encapsulate the core utility the agent provides. An agent’s relevance and specialization are directly tied to the breadth and precision of its published skills.

\textbf{Task} is the atomic unit of work delegation. It specifies the skill to be executed, along with input parameters and contextual metadata. Tasks are issued by Client Agents and processed by Remote Agents, enabling asynchronous or synchronous collaboration. By structuring intention and invocation in a standardized format, Tasks allow A2A agents to operate interoperably across diverse systems.

\textbf{Messages} serve as the primary communication channel between agents. These encapsulate data exchange and coordination activities such as task submission, intermediate status updates, or artifact delivery—and can be composed of multiple typed parts including plain text, structured data, or file references. Without Messages, inter-agent interaction would not be possible, making them foundational to the A2A protocol.
 \textbf{Artifacts} are the tangible outputs of skill execution. Once a Remote Agent completes a task, it generates Artifacts that may contain structured responses, computed results, documents, or linked data. These outputs are transmitted back to the Client Agent, which may render them to the User or incorporate them into downstream processes. Artifacts represent the materialized knowledge or value created through agentic collaboration.





\subsection{A2A Transport Layer and Communication}

The A2A protocol supports multiple transport mechanisms to enable communication between Client and Remote Agents, tailored to support both synchronous and asynchronous workflows. When real-time streaming is required and supported by both parties, \textbf{Server-Sent Events (SSE)} can be employed. SSE establishes a persistent HTTP connection over which the Remote Agent can send live status updates or partial Artifacts to the Client Agent, facilitating continuous feedback during long-running tasks.

In scenarios where persistent connections are impractical such as mobile or distributed deployments—the protocol accommodates \textbf{Push Notifications}. These are implemented through a \texttt{PushNotificationService} interface that allows the Remote Agent to notify the Client about task progress or completion via out-of-band channels. This model is particularly suited for latency-tolerant workflows and background task orchestration.

All core task communications in A2A adhere to the \textbf{JSON-RPC 2.0} specification. This ensures a standardized format for method invocation, parameter passing, and result encapsulation. Additionally, Remote Agent discovery is bootstrapped via HTTP \texttt{GET} requests directed at the Agent’s endpoint, specifically retrieving its Agent Card as a structured representation of supported capabilities. Together, these mechanisms enable flexible, interoperable, and extensible communication across diverse runtime environments.





\subsection{A2A Remote Agent (Server) Lifecycle}

The lifecycle of a Remote Agent in the A2A protocol follows a structured progression through four key phases: \textbf{Creation}, \textbf{Operation}, \textbf{Update}, and \textbf{Termination}. Each phase reflects a distinct set of responsibilities critical to ensuring secure, discoverable, and reliable agent behavior.

\textbf{Creation} begins with the publication of the Agent Card, a JSON-formatted document served at \texttt{/.well-known/agent.json}, which declares metadata such as the agent’s name, version, supported skills, and authentication schemes. Once the Agent Card is made available, the agent service is deployed at a designated endpoint and configured to handle JSON-RPC 2.0 requests over HTTP. To complete the creation phase, the Remote Agent must implement the declared authentication mechanisms, enabling secure client verification and access control.

During \textbf{Operation}, the Remote Agent processes Tasks submitted by Client Agents in accordance with its advertised skills. This includes receiving structured Task payloads, executing the associated skill logic, and managing ongoing communication through JSON-RPC status messages and Artifact delivery. If supported, the agent may also stream asynchronous updates using Server-Sent Events (SSE) or deliver them through a registered \texttt{PushNotificationService}. The agent is responsible for maintaining internal task state throughout execution to ensure consistency and traceability across interactions.

In the \textbf{Update} phase, the Remote Agent refreshes its capabilities or configurations. This includes incrementing the version field in the Agent Card, adding new skills or authentication modes, and applying security patches to maintain compliance. The agent may also deprecate outdated features or legacy interfaces, ideally signaling these changes to clients through updated documentation or explicit lifecycle status fields.

Finally, during \textbf{Termination}, the Remote Agent gracefully winds down its operations. In-flight Tasks are driven to completion or transitioned to a terminal state, and any open SSE streams are closed. The service then deregisters its Agent Card—by removing or archiving the published metadata and releases allocated system resources, ensuring a clean shutdown with no residual exposure or stale endpoints. A well-defined Remote Agent lifecycle enhances discoverability, promotes interoperability, and ensures that agent-based collaboration remains secure, consistent, and predictable within the broader A2A ecosystem.

  


\subsection{Security Challenges and Mitigations Across the A2A Lifecycle}

A secure A2A deployment requires addressing threats across all lifecycle phases creation, operation, update, and termination. Table~\ref{tab:a2a-security-mitigations} consolidates principal vulnerabilities and corresponding mitigation strategies, drawn from official A2A protocol references and recent security analyses.

% \begin{table}[h]
%   \centering
%   \renewcommand{\arraystretch}{1.25}
%   \rowcolors{2}{gray!15}{white}
%   \captionsetup{justification=centering,aboveskip=5pt,belowskip=5pt}
%   \caption{A2A Lifecycle Security Challenges and Mitigations}
%   \label{tab:a2a-security-mitigations}
%   \begin{tabularx}{\linewidth}{|
%       >{\centering\arraybackslash}p{2.1cm}|
%       >{\raggedright\arraybackslash}p{3.3cm}|
%       >{\raggedright\arraybackslash}p{4.3cm}|
%       >{\raggedright\arraybackslash}p{4.3cm}|}
%     \toprule
%     \rowcolor{gray!30}
%     \textbf{Phase} & \textbf{Security Challenge} & \textbf{Threat Description} & \textbf{Mitigation Strategy} \\
%     \midrule

%     \textbf{Creation}
%     & Agent Card \& Manifest Spoofing
%     & Adversaries may tamper with the Agent Card served at \texttt{/.well-known/agent.json}, impersonating a trusted Remote Agent.
%     & Digitally sign Agent Cards, verify checksums at retrieval, and harden CI/CD pipelines to prevent manifest injection.~\cite{googleA2ARepo} \\

%     \midrule
%     \textbf{Operation}
%     & Task Injection \& Command Forgery
%     & Malicious \texttt{tasks/send} or \texttt{tasks/sendSubscribe} calls may manipulate JSON-RPC parameters to trigger unintended skill execution.
%     & Enforce TLS and JSON Web Signatures (JWS) on RPC payloads; validate schemas rigorously and issue scoped capability tokens.~\cite{redteaming2025} \\

%     \cline{2-4}
%     & Push Notification Hijacking
%     & Attackers may spoof SSE endpoints or intercept Push notifications, leading to fake status updates or data leakage.
%     & Authenticate notification channels; isolate streams per session; verify signatures on all pushed events.~\cite{firewalls2025} \\

%     \midrule
%     \textbf{Update}
%     & Unauthorized Capability Injection \& Version Drift
%     & Unauthorized actors may add hidden skills/auth methods to Agent Cards, or clients may rely on stale versions.
%     & Use immutable, versioned manifests; detect drift automatically using GitOps; require signed diffs.~\cite{mediumA2A2025} \\

%     \midrule
%     \textbf{Termination}
%     & Orphaned Resources \& Audit Gaps
%     & Failure to revoke tokens, close SSE streams, or deregister agents can expose lingering endpoints and hinder forensic review.
%     & Use shutdown hooks to drain Tasks and SSE connections; revoke credentials; centralize audit logging and retention policies.~\cite{googleA2ASecurityPolicy} \\

%     \bottomrule
%   \end{tabularx}
% \end{table}

\begin{table}[ht]
   \small
  \centering
  \renewcommand{\arraystretch}{1.2}
  \rowcolors{2}{gray!10}{white}
  \captionsetup{justification=centering}
  \caption{A2A Lifecycle Security Challenges and Mitigation Strategies}
  \label{tab:a2a-security-mitigations}
\begin{tabularx}{\textwidth}{|
    >{\centering\arraybackslash}p{2.1cm}|
    >{\raggedright\arraybackslash}X|
    >{\raggedright\arraybackslash}X|
    >{\raggedright\arraybackslash}X|}

    \hline
    \rowcolor{gray!30}
    \textbf{Phase} & \textbf{Security Challenge} & \textbf{Threat Description} & \textbf{Mitigation Strategy} \\
    \hline

    \textbf{Creation}
    & Agent Card \& Manifest Spoofing
    & Adversaries may tamper with the Agent Card at \texttt{/.well-known/agent.json}, impersonating a trusted Remote Agent.
    & Digitally sign Agent Cards, verify checksums during retrieval, and harden CI/CD pipelines to prevent injection~\cite{google2024a2a}. \\

    \hline

    \textbf{Operation}
    & Task Injection \& Command Forgery
    & Malicious \texttt{tasks/send} or \texttt{tasks/sendSubscribe} calls may manipulate JSON-RPC to trigger unauthorized execution.
    & Enforce TLS, use JSON Web Signatures (JWS), validate schemas, and issue scoped capability tokens~\cite{redteaming2025}. \\

    & Push Notification Hijacking
    & Attackers may spoof SSE endpoints or intercept notifications, leading to fake updates or leakage.
    & Authenticate notification channels, isolate streams per session, and sign pushed events~\cite{firewalls2025}. \\

    \hline

    \textbf{Update}
    & Unauthorized Capability Injection \& Version Drift
    & Unauthorized actors may add hidden skills to Agent Cards, or clients may operate on outdated configurations.
    & Use immutable, versioned manifests, detect drift with GitOps, and require signed manifest diffs~\cite{mediumA2A2025}. \\

    \hline

    \textbf{Termination}
    & Orphaned Resources \& Audit Gaps
    & Tokens, SSE streams, or agent registrations may persist after use, complicating security audits.
    & Implement shutdown hooks, revoke credentials, and centralize audit logging with enforced retention~\cite{googleA2aBlog}. \\

    \hline
  \end{tabularx}
\end{table}



% \section{ACP Core Architecture}

% The Agent Communication Protocol (ACP) defines a layered, REST-native framework for interoperable AI agents. 

% Its static architecture comprises distinct actors and protocol layers, each responsible for a well-defined set of functions.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{acp.png}
    % \includesvg[width=\linewidth]{acp.svg}
    \caption{An overview of ACP}
    \label{fig:ACP}
\end{figure}

% \subsection{ACP Architecture Overview}
% At its core, the Agent Communication Protocol (ACP) defines a lightweight three‐role architecture that standardizes how AI agents are discovered, invoked, and managed. These roles work together to ensure that any client can locate services, send structured requests, and receive ordered, multimodal responses without custom integrations for each agent.

% \begin{itemize}
%   \item \textbf{Agent Client.} Discovers available agents, packages user intent into ACP‐compliant messages, manages session context, and renders the returned response parts (e.g., text, artifacts, binary data).
%   \item \textbf{ACP Server.} Acts as the central broker: it maintains the Agent Registry (leveraging the Agent Detail Schema for metadata), enforces protocol rules (authentication, rate limiting), routes client requests to the appropriate agent, and streams ordered responses back to the client.
%   \item \textbf{ACP Agent.} Implements domain‐specific business logic as a stateless or stateful service. It ingests structured multi‐part messages, executes the requested computation, and emits ordered response parts in accordance with the Message Structure specification.
% \end{itemize}




\section{ACP Architecture}

The Agent Communication Protocol (ACP) architecture is a modular, HTTP-based system designed to facilitate interaction between clients and agents. It is composed of three primary components: the ACP Client, the ACP Server, and one or more ACP Agents. Clients communicate with servers using standardized REST APIs, sending structured multi-modal messages that agents process and responds.

The \textbf{ACP Client} initiates communication by submitting requests in ACP-compliant format. It supports message composition using ordered message parts, session-based interactions for multi-turn workflows, and both synchronous and streaming execution modes. Error responses follow a unified structure, and standard HTTP authentication methods such as Bearer tokens, Basic Auth, and JWTs are supported.

The \textbf{ACP Server} acts as a middleware component, translating external HTTP requests into internal agent executions. It manages agent lifecycle phases including execution and optional session persistence. The server is stateless by default, making it compatible with load balancers and orchestration platforms such as Kubernetes. Secure communication is achieved via TLS, and observability is supported through OpenTelemetry-based tracing and metrics.

The \textbf{ACP Agent} is the execution component defined using a decorator-based configuration. Agents process structured requests consisting of ordered message parts and generate responses that conform to ACP’s message format. They support both stateless and session-aware operation, including features such as await/resume for interactive use cases. Agent metadata enables discovery through runtime APIs, offline packaging, or public manifest files.

Together, these three components form a framework that supports agent communication through standardized protocols, structured messaging, and flexible deployment strategies.




% \section{ACP Main Components}
% An ACP interaction revolves around several core objects that define its behavior, capabilities, and interactions. These components are essential for any agent to operate effectively within an ACP system. The following are the principal components and their roles:

% \begin{itemize}
%     \item \textbf{Agent Detail: Self-description and discovery mechanism.} Agent Detail is a JSON/YAML document that publicly announces the agent’s identity, capabilities, and runtime health. It includes metadata such as the agent’s name, description, supported operations, content types, and performance metrics. Clients use this “business card” to discover and evaluate agents before invocation.

%     \item \textbf{Discovery Mechanisms: Finding agents at runtime.} Discovery Mechanisms define how clients locate available agents—whether through a centralized registry API, well-known manifest files (e.g., \texttt{/.well-known/agent.yml}), or offline embedded metadata (e.g., container labels). Effective discovery lets clients integrate new agents dynamically without manual configuration.

%     \item \textbf{Task Request: The unit of delegated work.} A Task Request is a structured multi-part message that encapsulates the client’s intent, specifying the target agent, operation name, and payload parts (text, files, or data URLs). Clients issue Task Requests to invoke agent functionality, supporting both synchronous calls and asynchronous streams.

%     \item \textbf{Message Structure: The communication envelope.} Message Structure defines how content is packaged and routed: an ordered list of parts, each carrying a MIME \texttt{content\_type} and either inline \texttt{content} or a \texttt{content\_url}. Optional \texttt{name} attributes mark artifacts, enabling clients to interpret and process complex, multimodal responses.

%     \item \textbf{Artifact: Results from agent execution.} Artifacts are the outputs produced when an ACP agent completes a Task Request. These may include plain text, binary files, images, or structured data payloads. Artifacts are delivered back to the client within the Message Structure, after which the client renders or further processes them.
% \end{itemize}

\subsection{ACP Main Components}

ACP interactions are governed by a set of core components that define agent behavior, enable runtime interoperability, and standardize task communication. Central to this architecture is the \textbf{Agent Detail}, a self-descriptive JSON or YAML document that serves as the agent’s public identity and capability profile. It provides essential metadata, including the agent’s name, available operations, supported content types, authentication schemes, and runtime diagnostics. Clients rely on Agent Detail as a precondition for invocation, enabling trust and selection without bespoke integration.

Complementing this, \textbf{Discovery Mechanisms} allow clients to locate agents dynamically at runtime. These mechanisms may be centralized—such as registry APIs—or decentralized, including manifest files hosted under well-known URLs (e.g., \texttt{/.well-known/agent.yml}) or embedded within deployment metadata like container labels. This discoverability layer decouples client logic from fixed configurations and supports scalable agent networks.

Once an agent is located, clients issue a \textbf{Task Request}, a structured unit of delegated work. Task Requests are composed of ordered message parts that specify the target operation and include textual inputs, binary payloads, or references to externally hosted data. This design accommodates both synchronous calls and long-running, asynchronous tasks.

All requests and responses conform to ACP’s \textbf{Message Structure}, which standardizes the communication envelope. Each message is an ordered list of parts, with explicit MIME \texttt{content\_type} annotations and either embedded \texttt{content} or dereferenceable \texttt{content\_url} values. Optional \texttt{name} attributes enable the use of semantically tagged Artifacts, facilitating downstream interpretation.

Finally, the result of agent execution is encapsulated in one or more \textbf{Artifacts}. These may consist of structured JSON outputs, plain text completions, binary files, or even nested message references. Artifacts are delivered as part of the Message Structure response and are subsequently rendered, stored, or chained into additional agent workflows, ensuring extensibility and composability across ACP-enabled systems.


\subsection{ACP Agent Lifecycle}

The lifecycle of an ACP agent closely mirrors the A2A framework’s four canonical phases: \textit{Creation}, \textit{Operation}, \textit{Update}, and \textit{Termination}. Each stage ensures that agent behavior remains discoverable, interoperable, and secure throughout its active deployment.

\textbf{Creation} begins with the configuration and deployment of the agent. This involves declaring the agent’s capabilities and metadata through an Agent Detail manifest, which is made accessible via an ACP-compliant server, such as an ASGI-based or built-in implementation. The agent is initialized with authentication mechanisms and routing logic that collectively secure both service discovery and downstream task execution.

During \textbf{Operation}, agents process structured \texttt{sendTask} requests submitted by clients. These requests contain encoded parameters required for task execution. The ACP runtime supports synchronous execution as well as incremental streaming of intermediate results. Each task progresses through well-defined states—such as \texttt{created}, \texttt{in\_progress}, or \texttt{awaiting} that are managed by the ACP execution engine. For multi-turn workflows, session-level persistence ensures continuity of context across multiple interactions.

In the \textbf{Update} phase, the Agent Detail manifest is refreshed to reflect changes in the agent’s behavior or capabilities. These updates may include new operations, supported MIME types, or version increments. Importantly, the discovery process is resilient to such changes: clients querying the agent registry retrieve the latest manifest without requiring direct API modification, thereby preserving backward compatibility.

\textbf{Termination} involves the graceful decommissioning of the agent. All active tasks are driven to completion, ongoing streams are closed, and the agent’s manifest is deregistered or marked as inactive to prevent future discovery. Any allocated resources are released, and session data is finalized to ensure a clean and auditable shutdown.




\subsection{Security Considerations Across the ACP Lifecycle}

ACP-based systems face distinct security challenges as they progress through their lifecycle phases—from agent registration to shutdown. Table~\ref{tab:acp-security-mitigations} summarizes key threats and their corresponding mitigation strategies, grounded in recent red-teaming, protocol, and platform-level research.

% \begin{table}[h]
%   \centering
%   \renewcommand{\arraystretch}{1.25}
%   \rowcolors{2}{gray!15}{white}
%   \captionsetup{justification=centering,aboveskip=5pt,belowskip=5pt}
%   \caption{ACP Lifecycle Security Challenges and Mitigations}
%   \label{tab:acp-security-mitigations}
%   \begin{tabularx}{\linewidth}{|
%       >{\centering\arraybackslash}p{2.1cm}|
%       >{\raggedright\arraybackslash}p{3.3cm}|
%       >{\raggedright\arraybackslash}p{4.3cm}|
%       >{\raggedright\arraybackslash}p{4.3cm}|}
%     \toprule
%     \rowcolor{gray!30}
%     \textbf{Phase} & \textbf{Security Challenge} & \textbf{Threat Description} & \textbf{Mitigation Strategy} \\
%     \midrule

%     \textbf{Creation}
%     & Metadata Spoofing \& Supply‐Chain Attacks
%     & An attacker may publish a counterfeit Agent Detail manifest (e.g., at \texttt{/.well-known/agent.yml}) impersonating a legitimate agent or injecting malicious skills.
%     & Digitally sign all manifests and verify signatures on discovery. Enforce supply-chain integrity via CI/CD signing and artifact validation.~\cite{beeai2024acp} \\

%     \midrule
%     \textbf{Operation}
%     & Message Tampering \& MITM
%     & Malicious actors may intercept or manipulate \texttt{sendTask}/\texttt{getTask} RPC calls, injecting payloads or corrupting message streams.
%     & Use TLS for transport-level encryption and JSON Web Signatures (JWS) on individual message parts.~\cite{redteaming2025} \\

%     \cline{2-4}
%     & Authentication \& Authorization Flaws
%     & Weak bearer token enforcement can permit unauthorized invocation, task cancellation, or agent misuse.
%     & Implement capability-scoped, short-lived tokens; support mutual TLS for identity binding and revocation.~\cite{mediumA2A2025} \\

%     \midrule
%     \textbf{Persistence}
%     & Session Hijacking \& Privacy Leakage
%     & Without strong session binding or encryption, multi-turn interactions risk replay attacks and token theft.
%     & Rotate session IDs per access, encrypt persisted context, and set minimal TTLs for tokens.~\cite{firewalls2025} \\

%     \midrule
%     \textbf{Update}
%     & Version Rollback \& Configuration Drift
%     & Unsynchronized updates may reintroduce known vulnerabilities through outdated code or manifests.
%     & Use immutable, versioned manifests and automate drift detection with GitOps tooling.~\cite{acmAgents2025} \\

%     \midrule
%     \textbf{Termination}
%     & Orphaned Resources \& Audit Gaps
%     & Unclosed SSE streams, unrevoked tokens, or missing audit logs hinder cleanup and incident forensics.
%     & Drain in-flight tasks on shutdown; revoke credentials; centralize and retain audit logs for compliance.~\cite{acmAgents2025} \\

%     \bottomrule
%   \end{tabularx}
% \end{table}

\begin{table}[ht]
  \small
  \centering
  \renewcommand{\arraystretch}{1.2}
  \rowcolors{2}{gray!10}{white}
  \captionsetup{justification=centering}
  \caption{ACP Lifecycle Security Challenges and Mitigation Strategies}
  \label{tab:acp-security-mitigations}
\begin{tabularx}{\textwidth}{|
    >{\centering\arraybackslash}p{2.1cm}|
    >{\raggedright\arraybackslash}X|
    >{\raggedright\arraybackslash}X|
    >{\raggedright\arraybackslash}X
|}
    \hline
    \rowcolor{gray!30}
    \textbf{Phase} & \textbf{Security Challenge} & \textbf{Threat Description} & \textbf{Mitigation Strategy} \\
    \hline

    \textbf{Creation}
    & Metadata Spoofing \& Supply Chain Attacks
    & Attackers may publish forged Agent Detail manifests (e.g., \texttt{/.well-known/agent.yml}) to impersonate agents or inject malicious skills.
    & Digitally sign all manifests, verify at discovery, and enforce CI/CD signature checks and artifact validation~\cite{beeai2024acp}. \\

    \hline

    \textbf{Operation}
    & Message Tampering \& MITM
    & Adversaries can intercept or alter \texttt{sendTask} or \texttt{getTask} RPC calls, leading to payload injection or message corruption.
    & Use TLS for transport security and sign each message part with JWS~\cite{redteaming2025}. \\

    & Auth Flaws \& Unauthorized Access
    & Weak bearer token enforcement may allow unauthorized execution or task disruption.
    & Apply capability-scoped, short-lived tokens; enforce mutual TLS with identity revocation~\cite{mediumA2A2025}. \\

    \hline

    \textbf{Persistence}
    & Session Hijacking \& Privacy Leaks
    & Replay attacks or token theft may occur in long-lived sessions without proper binding or encryption.
    & Rotate session IDs, encrypt persisted context, and minimize token lifetimes~\cite{firewalls2025}. \\

    \hline

    \textbf{Update}
    & Version Rollback \& Config Drift
    & Stale manifests or software may reintroduce patched vulnerabilities post-update.
    & Enforce immutable, versioned manifests and use GitOps to detect drift~\cite{acmAgents2025}. \\

    \hline

    \textbf{Termination}
    & Orphaned Resources \& Audit Gaps
    & Failing to revoke tokens or close SSE streams complicates cleanup and forensics.
    & Drain active tasks, revoke credentials, and centralize audit logging with retention policies~\cite{acmAgents2025}. \\

    \hline
  \end{tabularx}
\end{table}


\section{ANP Architecture}
Agent Network Protocol (ANP) is a decentralized, peer-to-peer communication standard designed for cross-platform agent interoperability on the open internet. ANP enables agents to autonomously discover, authenticate, and interact using structured metadata and AI-native data exchange. The following sections align ANP's architecture with a standardized lifecycle and modular framework, modeled consistently with MCP, A2A, and ACP.

\begin{figure}
    \centering
    \includegraphics[width=0.55\linewidth]{anp-architecture.png}
    \caption{An overview of ANP \cite{anp2024website,anp2024github}}
    \label{fig:ANP}
\end{figure}




\subsection{Core Components}
The Agent Network Protocol (ANP) is underpinned by a set of foundational components that collectively support decentralized identity, semantic self-description, discovery, and adaptive interaction. At the core is the \textbf{Agent Identity}, which employs Decentralized Identifiers (DIDs) to uniquely identify agents across platforms. Specifically, ANP adopts the \texttt{did:wba} method, where each identifier corresponds to an HTTPS-hosted DID document, thereby leveraging existing Web infrastructure for decentralized identity resolution.

Building upon this identity layer is the \textbf{Agent Description}, implemented through the Agent Description Protocol (ADP). These JSON-LD formatted documents contain structured metadata about the agent, including its name, capabilities, supported protocols, authentication schemes, and service endpoints. They serve as the agent’s publicly accessible profile, facilitating interoperability and semantic understanding.

Agents expose their presence and capabilities through a \textbf{Discovery Directory}, typically located at the standardized \texttt{.well-known/agent-descriptions} endpoint. This directory enables both human users and automated systems to retrieve a list of available agents under a given domain, forming the basis for scalable agent indexing and search.

To support interaction, ANP accommodates two categories of communication interfaces: \textbf{Structured Interfaces}, such as JSON-RPC and OpenAPI, and \textbf{Natural Language Interfaces}, defined via YAML or equivalent schema files. Both interface types are declared within the agent’s description and enable flexible interaction patterns suited to varying complexity and use cases.

Finally, the \textbf{Meta-Protocol Negotiator} facilitates dynamic protocol alignment between agents. This mechanism allows agents to exchange natural language descriptions of their communication requirements and capabilities, from which compatible interaction protocols can be negotiated and instantiated. By supporting runtime adaptability and negotiation, this layer ensures seamless interoperability even among heterogeneous agent ecosystems.

\subsection{ANP Agent Lifecycle}

The ANP agent lifecycle adheres to the canonical phases of \textit{Creation}, \textit{Operation}, \textit{Update}, and \textit{Termination}, reflecting the decentralized design principles of the Agent Network Protocol. Each phase ensures that agents remain discoverable, verifiable, and interoperable within a globally distributed agent ecosystem.

\textbf{Creation} initiates with the generation of a decentralized identifier (DID) using the \texttt{did:wba} method. This identifier is associated with a publicly resolvable HTTPS endpoint hosting the agent’s DID document. In parallel, the agent prepares a self-descriptive Agent Description (ADP) document in JSON-LD format, detailing its services, supported protocols, and authentication mechanisms. The ADP is then published under a standardized path such as \texttt{/.well-known/agent-descriptions}, enabling web-based discovery or optional registration with search agents.

During the \textbf{Operation} phase, agents authenticate and interact via cryptographic credentials defined in their DID documents. All communications follow structured interaction models declared in the ADP—such as JSON-RPC for precise invocation or YAML-based interfaces for natural language negotiation. Secure transport is established using HTTPS and, where applicable, real-time communication is supported through mechanisms such as Server-Sent Events (SSE) or long polling. Agents act autonomously or cooperatively by invoking external services, interpreting requests, and returning results in a standardized format.

The \textbf{Update} phase allows agents to revise their ADP documents and associated DID metadata to reflect evolving capabilities or interface changes. These updates are automatically propagated through recurring crawls by indexing services or explicitly refreshed via active discovery endpoints. Because agent identity and service descriptions are independently versioned and published, clients can dynamically adapt to updates without breaking existing integrations.

\textbf{Termination} involves the intentional deactivation of an agent. This includes the removal or archival of its DID document and the depublication of its ADP endpoint from discovery directories. Any issued authentication tokens, access credentials, or associated metadata must be revoked to ensure security. A clean shutdown preserves the integrity of the agent ecosystem by preventing stale or orphaned entries from persisting in discovery indexes or trusted registries.



\subsection{Transport and Format}
ANP relies on HTTP(S) for transport and JSON-LD for data formatting. Schema.org vocabularies and contexts like `ad:` are used for semantic clarity. Structured interfaces such as JSON-RPC and OpenAPI are compatible and embedded via ADP.

\subsection{Security Considerations Across the ANP Lifecycle}
Table~\ref{tab:anp-security-mitigations} summarizes major threats and corresponding mitigations across the ANP lifecycle.


\begin{table}
    \small
  \centering
  \renewcommand{\arraystretch}{1.3}
  \rowcolors{2}{gray!10}{white}
  \captionsetup{justification=centering}
  \caption{ANP Lifecycle Security Challenges and Mitigation Strategies}
  \label{tab:anp-security-mitigations}
  \begin{tabularx}{\textwidth}{|
      >{\centering\arraybackslash}p{2.3cm} |
      >{\raggedright\arraybackslash}X |
      >{\raggedright\arraybackslash}X |
      >{\raggedright\arraybackslash}X |
  }
    \hline
    \rowcolor{gray!30}
    \textbf{Phase} & \textbf{Security Challenge} & \textbf{Threat Description} & \textbf{Mitigation Strategy} \\
    \hline

    \textbf{Creation}
    & Identity Spoofing
    & DID documents may be spoofed or hosted insecurely, leading to agent misidentification.
    & Enforce HTTPS-hosted DIDs, verify with DNS records, and require DID signature validation. \\

    \textbf{Operation}
    & Unverified Agents
    & Malicious actors may bypass DID checks or use spoofed credentials.
    & Authenticate via DID public keys and validate humanAuthorization for sensitive actions. \\

    & Interface Tampering
    & Agents may alter structured interfaces or inject into natural language endpoints.
    & Require cryptographic signing of interfaces and log access events with source metadata. \\

    \textbf{Update}
    & Stale Descriptions
    & Outdated or manipulated agent metadata may deceive clients.
    & Automate crawling of agent descriptions and validate against known-good hashes. \\

    \textbf{Termination}
    & Orphaned Identifiers
    & Expired DIDs or agent declarations (ADPs) may persist in registries or caches.
    & Use expiration timestamps and require revocation signaling during deregistration. \\

    \hline
  \end{tabularx}
\end{table}


\begin{table}[h]
    \small
  \centering
  \renewcommand{\arraystretch}{1.2}
  \rowcolors{2}{gray!10}{white}
  \caption{Comparison of MCP, ACP, A2A, and ANP Protocols}
  \captionsetup{justification=centering}
  \label{tab:agent-protocol-comparison}
  \begin{tabularx}{\textwidth}{|
      >{\raggedright\arraybackslash}p{2.2cm}|
      >{\raggedright\arraybackslash}X|
      >{\raggedright\arraybackslash}X|
      >{\raggedright\arraybackslash}X|
      >{\raggedright\arraybackslash}X|
  }
    \toprule
    \rowcolor{gray!25}
    \textbf{Aspect} &
    \textbf{MCP (Model Context Protocol)} &
    \textbf{ACP (Agent Communication Protocol)} &
    \textbf{A2A (Agent-to-Agent Protocol)} &
    \textbf{ANP (Agent Network Protocol)} \\
    \midrule

    \textbf{Architecture Model} &
    Client–Server with JSON-RPC primitives &
    Brokered Client–Server (Registry + Task Routing) &
     Peer-like Client $\leftrightarrow$ Remote Agent
&
    Decentralized Peer-to-Peer \\

    \textbf{Agent Discovery} &
    Manual registration or static URL lookup &
    Registry-based   &
    %\texttt{/.well-known/agent.yml} &
    Agent Card retrieval via HTTP &
    % \texttt{/.well-known/agent-descriptions} +
    Search Engine Discovery \\

    \textbf{Identity \& Auth} &
    Token-based auth; supports DIDs optionally &
    Bearer tokens, mutual TLS, JWS &
    DID-based handshake or out-of-band headers &
    Decentralized Identifiers (DID), especially \texttt{did:wba} \\

    \textbf{Message Format} &
    JSON-RPC 2.0 with Prompts, Tools, Resources &
    Structured multipart messages with MIME-typed parts &
    Task + Artifact messaging over JSON &
    JSON-LD with Schema.org and ADP/Meta-Protocol negotiation \\

    \textbf{Core Components} &
    Tools, Prompts, Resources, Sampling &
    Agent Detail, Message, Task Request, Artifact &
    Agent Card, Task, Message, Artifact &
    DID Document, Agent Description, Meta-Protocol, Structured Interface \\

    \textbf{Transport Layer} &
    HTTP, Stdio, Server-Sent Events (SSE) &
    HTTP with incremental streams &
    HTTP with optional SSE + Push Notifications &
    HTTP with JSON-LD over TLS \\

    \textbf{Session Support} &
    Stateless + optional persistent tool context &
    Session-aware with run state tracking &
    Session-aware or stateless; client-managed IDs &
    Stateless; DID-authenticated tokens used across connections \\

    \textbf{Target Scope} &
    LLM $\leftrightarrow$ External Tool/Service integration &
    Model-Agnostic, Infrastructure-level agents &
    Trusted enterprise task delegation &
    Open Internet agent interconnectivity \\

    \textbf{Primary Use Case} &
    Augment LLMs with external capabilities (e.g., code, search) &
    Secure, typed message exchange for diverse agents &
    Multi-agent workflows within organizational trust boundaries &
    Cross-platform agent discovery, secure P2P execution \\

    \textbf{Strengths} &
    Tight LLM integration; resource injection &
    Multimodal messaging; brokered registry; tool modularity; Offline Agent Discovery &
    Inter-agent negotiation; artifact-driven delegation &
    DID-based trustless identity; AI-native protocol negotiation \\

    \textbf{Limitations} &
    Centralized server assumption; prompt injection risks &
    Registry required; strong assumptions on server control &
    Enterprise-centric; assumes agent catalog &
    High negotiation overhead; evolving adoption ecosystem \\

    \bottomrule
  \end{tabularx}
\end{table}


% \begin{table}[h]
%   \centering
%   \renewcommand{\arraystretch}{1.3}
%     % \renewcommand{\arraystretch}{1.2}
%   \rowcolors{2}{gray!10}{white}
%   \captionsetup{justification=centering}
%   % \rowcolors{2}{gray!15}{white}
%   % \captionsetup{justification=centering,aboveskip=5pt,belowskip=5pt}
%   \caption{ANP Lifecycle Security Challenges and Mitigations}
%   \label{tab:anp-security-mitigations}
% \begin{tabularx}{\textwidth}{|
%     >{\centering\arraybackslash}p{2.1cm}|
%     >{\raggedright\arraybackslash}X|
%     >{\raggedright\arraybackslash}X|
%     >{\raggedright\arraybackslash}X|}

%     \toprule
%     \rowcolor{gray!30}
%     \textbf{Phase} & \textbf{Security Challenge} & \textbf{Threat Description} & \textbf{Mitigation Strategy} \\
%     \midrule
%     \textbf{Creation} & Identity Spoofing & DID documents may be spoofed or improperly hosted, leading to misidentification. & Enforce HTTPS-based hosting, DNS validation, and DID document signature verification. \\
%     \midrule
%     \textbf{Operation} & Unverified Agents & Malicious agents may bypass DID authentication or use invalid credentials. & Authenticate using DID public keys and verify humanAuthorization for sensitive actions. \\
%     \cline{2-4}
%     & Interface Tampering & Structured interfaces or natural language endpoints may be altered or injected. & Require interface signing and log all interface access requests with source metadata. \\
%     \midrule
%     \textbf{Update} & Stale Descriptions & Outdated or manipulated agent descriptions may mislead others. & Automate re-crawling of agent descriptions and check against previous hashes. \\
%     \midrule
%     \textbf{Termination} & Orphaned Identifiers & Decommissioned DIDs or ADPs may persist in registries or caches. & Use expiration timestamps and require revocation signaling during termination. \\
%     \bottomrule
%   \end{tabularx}
% \end{table}





% \section{Security Considerations}
% As ACP—based systems traverse their lifecycle, they face distinct security risks that must be understood and addressed holistically. We organize these concerns into two parts: the specific challenges encountered at each lifecycle phase, and the corresponding mitigation strategies.

% \subsection{Security Challenges Across the ACP Lifecycle}
% ACP agents encounter unique threats at each phase of their lifecycle:
% \begin{itemize}[leftmargin=*]
%   \item \textbf{Creation:} Metadata spoofing and supply-chain attacks can arise if an adversary publishes a counterfeit Agent Detail manifest (e.g., in \texttt{/.well-known/agent.yml}), impersonating a trusted service or injecting malicious capabilities.
%   \item \textbf{Operation:} Message tampering and man-in-the-middle (MITM) attacks on \texttt{sendTask}/\texttt{getTask} exchanges can corrupt data streams or inject dangerous payloads. Concurrently, weak or inconsistent bearer-token enforcement may enable unauthorized invocation or cancellation of tasks.
%   \item \textbf{Persistence:} Session hijacking and privacy leakage become possible when multi-turn contexts are stored server-side without proper session binding or encryption, opening opportunities for replay or eavesdropping.
%   \item \textbf{Update:} Version rollback and configuration drift risk reintroducing known vulnerabilities if deployed agent versions fall out of sync with their published manifests.
%   \item \textbf{Termination:} Orphaned resources—such as lingering SSE streams or incomplete audit logs—can leave credentials exposed and hinder post-incident forensics.
% \end{itemize}

% \subsection{Mitigation Strategies Across the ACP Lifecycle}
% To harden ACP deployments, we recommend:
% \begin{itemize}[leftmargin=*]
%   \item \textbf{Creation:} Digitally sign Agent Detail manifests and enforce supply-chain integrity checks in CI/CD pipelines to guarantee metadata authenticity.
%   \item \textbf{Operation:} Employ end-to-end encryption (TLS) and per-part JSON-Web-Signatures (JWS), combined with scoped, short-lived bearer tokens or mutual TLS, to prevent tampering and unauthorized access.
%   \item \textbf{Persistence:} Rotate session identifiers on each access, encrypt persisted contexts at rest, and enforce minimal token time-to-live (TTL) to mitigate hijacking and eavesdropping.
%   \item \textbf{Update:} Use immutable, versioned manifests and automated drift-detection tooling to ensure deployments match published metadata and prevent rollback attacks.
%   \item \textbf{Termination:} Implement graceful shutdown hooks to drain in-flight runs and close streams, and centralize logging and audit trails to support rapid incident response and resource cleanup.
% \end{itemize}

% \subsection{Security Challenges Across the ACP Lifecycle}
% Table~\ref{tab:acp-security-challenges} summarizes the principal threats at each phase, with boxed reference links and citations.

% \begin{table}[h]
%   \centering
%   \renewcommand{\arraystretch}{1.3}
%   \rowcolors{2}{gray!15}{white}
%   \captionsetup{justification=centering,aboveskip=5pt,belowskip=5pt}
%   \caption{ACP Lifecycle Security Challenges}
%   \label{tab:acp-security-challenges}
%   \begin{tabularx}{\linewidth}{|
%       >{\centering\arraybackslash}p{2.2cm}|
%       >{\centering\arraybackslash}p{3.0cm}|
%       p{6.0cm}|
%       >{\centering\arraybackslash}p{3.2cm}|}
%     \toprule
%     \rowcolor{gray!30}
%     \textbf{Phase} & \textbf{Challenge} & \textbf{Description} & \textbf{Reference} \\
%     \midrule
%     \textbf{Creation}
%       & Metadata Spoofing \& Supply‐Chain Attacks
%       & An adversary could publish a counterfeit Agent Detail manifest (e.g.\ in \texttt{/.well-known/agent.yml}), impersonating a trusted service or injecting malicious capabilities.
%       & \fbox{\href{https://github.com/i-am-bee/beeai}{GitHub: ACP Repo}}~\cite{beeaiACP} \\
%     \hline
%     \textbf{Operation}
%       & Message Tampering \& MITM
%       & During \texttt{sendTask}/\texttt{getTask} exchanges, attackers may intercept or alter message parts—injecting malicious payloads or corrupting data streams.
%       & \fbox{\href{https://arxiv.org/abs/2502.#####}{Red‐Teaming LLM Multi‐Agent Systems}}~\cite{redteaming2025} \\
%     % next row in same phase
%       & Authentication \& Authorization Flaws
%       & Weak or inconsistent enforcement of bearer tokens or capability‐based permissions can allow unauthorized invocation or cancellation of tasks.
%       & \fbox{\href{https://medium.com/@author/a2a-protocol-guide}{A2A Protocol Guide}}~\cite{mediumA2A2025} \\
%     \hline
%     \textbf{Persistence}
%       & Session Hijacking \& Privacy Leakage
%       & Multi‐turn sessions store context server‐side; without proper session binding or encryption, tokens can be stolen, enabling replay or eavesdropping.
%       & \fbox{\href{https://arxiv.org/abs/2502.#####}{Firewalls to Secure Dynamic LLM Agentic Networks}}~\cite{firewalls2025} \\
%     \hline
%     \textbf{Update}
%       & Version Rollback \& Configuration Drift
%       & Rollback to older agent versions or out‐of‐sync manifests can reintroduce vulnerabilities.
%       & \fbox{\href{https://dl.acm.org/doi/10.1145/#####}{AI Agents Under Threat}}~\cite{acmAgents2025} \\
%     \hline
%     \textbf{Termination}
%       & Orphaned Resources \& Audit Gaps
%       & Improper cleanup of in‐flight runs or lingering SSE streams may leave credentials or memory exposed; missing audit logs hinder incident response.
%       & \fbox{\href{https://dl.acm.org/doi/10.1145/#####}{AI Agents Under Threat}}~\cite{acmAgents2025} \\
%     \bottomrule
%   \end{tabularx}
% \end{table}

% \subsection{Mitigation Strategies Across the ACP Lifecycle}
% \begin{itemize}[leftmargin=*]
%   \item \textbf{Manifest Integrity:} Digitally sign Agent Detail manifests and verify signatures on discovery.  
%   \item \textbf{End-to-End Encryption \& Signing:} Use TLS for transport and JSON-Web-Signatures on individual message parts.  
%   \item \textbf{Capability-Based Tokens:} Issue scoped, short-lived bearer tokens per agent and operation.  
%   \item \textbf{Drift Detection:} Automate comparison of deployed agent versions against published manifests to prevent rollback attacks.  
%   \item \textbf{Session Hygiene:} Rotate session IDs on each access, encrypt persisted context at rest, and enforce minimal token TTLs.  
%   \item \textbf{Centralized Logging \& Auditing:} Implement graceful shutdown hooks, drain in-flight runs, and collect comprehensive audit trails for rapid incident response.
% \end{itemize}




% \section{ANP Architecture}

% The Agent Network Protocol (ANP) defines how autonomous agents on the open Internet discover one another, establish trust, and exchange data and services in a uniform, secure manner.

% \subsection{Core Components}
% \begin{itemize}
%   \item \textbf{Peer Agent:} Each participant acts as both client and server, owning a decentralized identifier (DID) and hosting its Agent Description.
%   \item \textbf{Decentralized Identity System:} Based on W3C DIDs (e.g., \texttt{did:wba}), it provides key resolution, authentication, and end-to-end encryption.
%   \item \textbf{Discovery Mechanism:}  
%     \begin{itemize}
%       \item Web–based lookup via \texttt{.well-known/agent-descriptions}.  
%       \item Optional private registries or search-engine indexing.
%     \end{itemize}
% \end{itemize}

% \subsection{Peer Agent}
% A Peer Agent owns its DID and Description document, and may both initiate and respond to requests.

% \subsubsection{Agent Responsibilities}
% \begin{itemize}
%   \item \textbf{Identity Management:} Generate/rotate key pairs; serve the DID document at \texttt{https://…/did.json}.
%   \item \textbf{Description Publication:} Publish a JSON–LD Agent Description listing services, interfaces, and security schemes.
%   \item \textbf{Request Handling:} Sign outgoing requests and verify signatures on incoming messages.
%   \item \textbf{Message \& Artifact Exchange:} Exchange structured payloads (tasks, queries, results) encoded in JSON–LD.
% \end{itemize}

% \subsection{DID Resolver}
% A library or service that maps a DID to its DID Document, retrieving:
% \begin{itemize}
%   \item Public keys for signature verification.
%   \item Service endpoints (e.g., URL of the Agent Description).
% \end{itemize}

% \subsection{Agent Description \& Discovery}
% \begin{itemize}
%   \item \textbf{Agent Description:} A JSON–LD document using schema.org vocabularies to describe an agent’s name, capabilities, interfaces, and security.
%   \item \textbf{Discovery Methods:}
%     \begin{itemize}
%       \item \emph{Web Discovery:} Static listing at \texttt{https://domain/.well-known/agent-descriptions}.
%       \item \emph{Private Registry:} Controlled listing for trusted peers.
%       \item \emph{Search Indexing:} Public descriptions indexed by crawlers for semantic lookup.
%     \end{itemize}
% \end{itemize}

% \subsection{Protocol Layers}
% \begin{enumerate}
%   \item \textbf{Identity \& Encryption Layer:} DID-based mutual authentication and TLS encryption.
%   \item \textbf{Meta-Protocol Layer:} Negotiation of protocol versions and JSON–LD contexts.
%   \item \textbf{Application Layer:} Invocation of natural–language or structured APIs (e.g., JSON–RPC).
% \end{enumerate}

% \subsection{Transport \& Data Format}
% \begin{itemize}
%   \item \textbf{Transport:} All communication occurs over HTTP(S).
%   \item \textbf{Payload:} JSON–LD with \texttt{@context} (e.g., W3C DID, schema.org).
%   \item \textbf{Advantages:}  
%     \begin{itemize}
%       \item Broad support across programming languages.  
%       \item Self-describing, linked–data semantics.  
%       \item Extensible via additional contexts.
%     \end{itemize}
% \end{itemize}


%  \section{Security Challenges in ANP}
% \begin{table}[h]
%   \centering
%   \renewcommand{\arraystretch}{1.3}
%   \rowcolors{2}{gray!15}{white}
%   \captionsetup{justification=centering,aboveskip=5pt,belowskip=5pt}
%   \caption{ANP Layer Security Challenges}
%   \label{tab:anp-security-challenges}
%   \begin{tabularx}{\linewidth}{|
%       >{\centering\arraybackslash}p{2.2cm}|
%       >{\centering\arraybackslash}p{3.0cm}|
%       X|}
%     \toprule
%     \rowcolor{gray!30}
%     \textbf{Layer} & \textbf{Threat} & \textbf{Description} \\
%     \midrule
%     \textbf{Identity \& Encryption}
%       & Identity Spoofing \& MITM
%       & Forged or tampered DID Documents allow an attacker to impersonate agents; unencrypted channels enable interception and alteration of messages. \\
%     \hline
%     \textbf{Meta-Protocol}
%       & Negotiation Poisoning
%       & Malicious or tampered meta-protocol proposals can force use of insecure transport or data formats, or introduce malicious code generation. \\
%     \hline
%     \textbf{Agent Description}
%       & Metadata Poisoning
%       & Tampering with JSON-LD Agent Description manifests to inject false capabilities or endpoints that execute unauthorized actions. \\
%     \hline
%     \textbf{Discovery}
%       & Discovery Flooding \& Poisoning
%       & Flooding \texttt{.well-known/agent-descriptions} or search-index poisoning with fake entries leads to resource exhaustion and misinformation. \\
%     \hline
%     \textbf{Application Privacy}
%       & Privacy Leakage
%       & Overexposed sensitive fields in descriptions or unencrypted message parts facilitate profiling and data breaches. \\
%     \bottomrule
%   \end{tabularx}
% \end{table}




\section{Comparison of Agent Protocols}

To facilitate a clearer understanding of how major agent interoperability protocols differ, Table~\ref{tab:agent-protocol-comparison} presents a side-by-side comparison of four widely discussed frameworks: Model Context Protocol (MCP), Agent Communication Protocol (ACP), Agent-to-Agent Protocol (A2A), and Agent Network Protocol (ANP). This structured analysis highlights their architectural choices, messaging formats, discovery methods, session models, and intended use cases, offering insights into their suitability across diverse deployment scenarios.





% \begin{table}[ht]
%   \centering
%   \renewcommand{\arraystretch}{1.35}
%   \rowcolors{2}{gray!10}{white}
%   \caption{Comparison of MCP, ACP, A2A, and ANP Protocols}
%   \label{tab:agent-protocol-comparison}
%   \begin{tabularx}{\textwidth}{|
%       >{\raggedright\arraybackslash}p{2.8cm}|
%       >{\raggedright\arraybackslash}p{3.1cm}|
%       >{\raggedright\arraybackslash}p{2.8cm}|
%       >{\raggedright\arraybackslash}p{2.7cm}|
%       >{\raggedright\arraybackslash}p{3.0cm}|
%   }
%     \toprule
%     \rowcolor{gray!25}
%     \textbf{Aspect} &
%     \textbf{MCP (Model Context Protocol)} &
%     \textbf{ACP (Agent Communication Protocol)} &
%     \textbf{A2A (Agent-to-Agent Protocol)} &
%     \textbf{ANP (Agent Network Protocol)} \\
%     \midrule

%     \textbf{Architecture Model} &
%     Client–Server with JSON-RPC primitives &
%     Brokered Client–Server (Registry + Task Routing) &
%     Peer-like Client ↔ Remote Agent &
%     Decentralized Peer-to-Peer \\

%     \textbf{Agent Discovery} &
%     Manual registration or static URL lookup &
%     Registry-based and \texttt{/.well-known/agent.yml} &
%     Agent Card retrieval via HTTP &
%     \texttt{/.well-known/agent-descriptions} + Search Engine Discovery \\

%     \textbf{Identity \& Auth} &
%     Token-based auth; supports DIDs optionally &
%     Bearer tokens, mutual TLS, JWS &
%     DID-based handshake or out-of-band headers &
%     Decentralized Identifiers (DID), especially \texttt{did:wba} \\

%     \textbf{Message Format} &
%     JSON-RPC 2.0 with Prompts, Tools, Resources &
%     Structured multipart messages with MIME-typed parts &
%     Task + Artifact messaging over JSON &
%     JSON-LD with Schema.org and ADP/Meta-Protocol negotiation \\

%     \textbf{Core Components} &
%     Tools, Prompts, Resources, Sampling &
%     Agent Detail, Message, Task Request, Artifact &
%     Agent Card, Task, Message, Artifact &
%     DID Document, Agent Description, Meta-Protocol, Structured Interface \\

%     \textbf{Transport Layer} &
%     HTTP, Stdio, Server-Sent Events (SSE) &
%     HTTP with incremental streams &
%     HTTP with optional SSE + Push Notifications &
%     HTTP with JSON-LD over TLS \\

%     \textbf{Session Support} &
%     Stateless + optional persistent tool context &
%     Session-aware with run state tracking &
%     Session-aware or stateless; client-managed IDs &
%     Stateless; DID-authenticated tokens used across connections \\

%     \textbf{Target Scope} &
%     LLM ↔ External Tool/Service integration &
%     Model-Agnostic, Infrastructure-level agents &
%     Trusted enterprise task delegation &
%     Open Internet agent interconnectivity \\

%     \textbf{Primary Use Case} &
%     Augment LLMs with external capabilities (e.g., code, search) &
%     Secure, typed message exchange for diverse agents &
%     Multi-agent workflows within organizational trust boundaries &
%     Cross-platform agent discovery, secure P2P execution \\

%     \textbf{Strengths} &
%     Tight LLM integration; resource injection &
%     Multimodal messaging; brokered registry; tool modularity &
%     Inter-agent negotiation; artifact-driven delegation &
%     DID-based trustless identity; AI-native protocol negotiation \\

%     \textbf{Limitations} &
%     Centralized server assumption; prompt injection risks &
%     Registry required; strong assumptions on server control &
%     Enterprise-centric; assumes agent catalog &
%     High negotiation overhead; evolving adoption ecosystem \\

%     \bottomrule
%   \end{tabularx}
% \end{table}


% \begin{table}[ht]
%   \centering
%   \renewcommand{\arraystretch}{1.35}
%   \rowcolors{2}{gray!10}{white}
%   \caption{Comparison of MCP, ACP, A2A, and ANP Protocols}
%   \label{tab:agent-protocol-comparison}
%   \begin{tabularx}{\textwidth}{|
%       >{\raggedright\arraybackslash}p{2.8cm}|
%       >{\raggedright\arraybackslash}p{3.1cm}|
%       >{\raggedright\arraybackslash}p{2.8cm}|
%       >{\raggedright\arraybackslash}p{2.7cm}|
%       >{\raggedright\arraybackslash}p{3.0cm}|
%   }
%     \toprule
%     \rowcolor{gray!25}
%     \textbf{Aspect} &
%     \textbf{MCP (Model Context Protocol)} &
%     \textbf{ACP (Agent Communication Protocol)} &
%     \textbf{A2A (Agent-to-Agent Protocol)} &
%     \textbf{ANP (Agent Network Protocol)} \\
%     \midrule

%     \textbf{Architecture Model} &
%     Client–Server with JSON-RPC primitives &
%     Brokered Client–Server (Registry + Task Routing) &
%     Peer-like Client ↔ Remote Agent &
%     Decentralized Peer-to-Peer \\

%     \textbf{Agent Discovery} &
%     Manual registration or static URL lookup &
%     Registry-based and \texttt{/.well-known/agent.yml} &
%     Agent Card retrieval via HTTP &
%     \texttt{/.well-known/agent-descriptions} + Search Engine Discovery \\

%     \textbf{Identity \& Auth} &
%     Token-based auth; supports DIDs optionally &
%     Bearer tokens, mutual TLS, JWS &
%     DID-based handshake or out-of-band headers &
%     Decentralized Identifiers (DID), especially \texttt{did:wba} \\

%     \textbf{Message Format} &
%     JSON-RPC 2.0 with Prompts, Tools, Resources &
%     Structured multipart messages with MIME-typed parts &
%     Task + Artifact messaging over JSON &
%     JSON-LD with Schema.org and ADP/Meta-Protocol negotiation \\

%     \textbf{Core Components} &
%     Tools, Prompts, Resources, Sampling &
%     Agent Detail, Message, Task Request, Artifact &
%     Agent Card, Task, Message, Artifact &
%     DID Document, Agent Description, Meta-Protocol, Structured Interface \\

%     \textbf{Transport Layer} &
%     HTTP, Stdio, Server-Sent Events (SSE) &
%     HTTP with incremental streams &
%     HTTP with optional SSE + Push Notifications &
%     HTTP with JSON-LD over TLS \\

%     \textbf{Session Support} &
%     Stateless + optional persistent tool context &
%     Session-aware with run state tracking &
%     Session-aware or stateless; client-managed IDs &
%     Stateless; DID-authenticated tokens used across connections \\

%     \textbf{Target Scope} &
%     LLM ↔ External Tool/Service integration &
%     Model-Agnostic, Infrastructure-level agents &
%     Trusted enterprise task delegation &
%     Open Internet agent interconnectivity \\

%     \textbf{Primary Use Case} &
%     Augment LLMs with external capabilities (e.g., code, search) &
%     Secure, typed message exchange for diverse agents &
%     Multi-agent workflows within organizational trust boundaries &
%     Cross-platform agent discovery, secure P2P execution \\

%     \textbf{Strengths} &
%     Tight LLM integration; resource injection &
%     Multimodal messaging; brokered registry; tool modularity &
%     Inter-agent negotiation; artifact-driven delegation &
%     DID-based trustless identity; AI-native protocol negotiation \\

%     \textbf{Limitations} &
%     Centralized server assumption; prompt injection risks &
%     Registry required; strong assumptions on server control &
%     Enterprise-centric; assumes agent catalog &
%     High negotiation overhead; evolving adoption ecosystem \\

%     \bottomrule
%   \end{tabularx}
% \end{table}


% \begin{table}[h] \centering \renewcommand{\arraystretch}{1.35} \rowcolors{2}{gray!10}{white} \caption{Comparison of MCP, ACP, A2A, and ANP Protocols} \label{tab:agent-protocol-comparison} \begin{tabularx}{\linewidth}{| >{\raggedright\arraybackslash}p{2.8cm}| >{\raggedright\arraybackslash}p{3.1cm}| >{\raggedright\arraybackslash}p{2.8cm}| >{\raggedright\arraybackslash}p{2.7cm}| >{\raggedright\arraybackslash}p{3.0cm}|} \toprule \rowcolor{gray!25} \textbf{Aspect} & \textbf{MCP (Model Context Protocol)} & \textbf{ACP (Agent Communication Protocol)} & \textbf{A2A (Agent-to-Agent Protocol)} & \textbf{ANP (Agent Network Protocol)} \ \midrule \textbf{Architecture Model} & Client–Server with JSON-RPC primitives & Brokered Client–Server (Registry + Task Routing) & Peer-like Client ↔ Remote Agent & Decentralized Peer-to-Peer \
% \textbf{Agent Discovery} & Manual registration or static URL lookup & Registry-based and \texttt{/.well-known/agent.yml} & Agent Card retrieval via HTTP & \texttt{/.well-known/agent-descriptions} + Search Engine Discovery \\

% \textbf{Identity \& Auth} & Token-based auth; supports DIDs optionally & Bearer tokens, mutual TLS, JWS & DID-based handshake or out-of-band headers & Decentralized Identifiers (DID), especially \texttt{did:wba} \\

% \textbf{Message Format} & JSON-RPC 2.0 with Prompts, Tools, Resources & Structured multipart messages with MIME-typed parts & Task + Artifact messaging over JSON & JSON-LD with Schema.org and ADP/Meta-Protocol negotiation \\

% \textbf{Core Components} & Tools, Prompts, Resources, Sampling & Agent Detail, Message, Task Request, Artifact & Agent Card, Task, Message, Artifact & DID Document, Agent Description, Meta-Protocol, Structured Interface \\

% \textbf{Transport Layer} & HTTP, Stdio, Server-Sent Events (SSE) & HTTP with incremental streams & HTTP with optional SSE + Push Notifications & HTTP with JSON-LD over TLS \\

% \textbf{Session Support} & Stateless + optional persistent tool context & Session-aware with run state tracking & Session-aware or stateless; client-managed IDs & Stateless; DID-authenticated tokens used across connections \\

% \textbf{Target Scope} & LLM ↔ External Tool/Service integration & Model-Agnostic, Infrastructure-level agents & Trusted enterprise task delegation & Open Internet agent interconnectivity \\

% \textbf{Primary Use Case} & Augment LLMs with external capabilities (e.g., code, search) & Secure, typed message exchange for diverse agents & Multi-agent workflows within organizational trust boundaries & Cross-platform agent discovery, secure P2P execution \\

% \textbf{Strengths} & Tight LLM integration; resource injection & Multimodal messaging; brokered registry; tool modularity & Inter-agent negotiation; artifact-driven delegation & DID-based trustless identity; AI-native protocol negotiation \\

% \textbf{Limitations} & Centralized server assumption; prompt injection risks & Registry required; strong assumptions on server control & Enterprise-centric; assumes agent catalog & High negotiation overhead; evolving adoption ecosystem \\

% \bottomrule
% \end{tabularx} \end{table}





% \begin{table}[h]
%   \centering
%   \renewcommand{\arraystretch}{1.3}
%   \rowcolors{2}{gray!15}{white}
%   \captionsetup{justification=centering,aboveskip=5pt,belowskip=5pt}
%   \caption{Comparison of MCP, A2A, ANP, and ACP Protocols}
%   \label{tab:protocol-comparison}
%   \begin{tabularx}{\linewidth}{|
%       >{\centering\arraybackslash}p{2.5cm}|
%       >{\centering\arraybackslash}p{2.3cm}|
%       >{\centering\arraybackslash}p{2.3cm}|
%       >{\centering\arraybackslash}p{2.3cm}|
%       >{\centering\arraybackslash}p{2.3cm}|}
%     \toprule
%     \rowcolor{gray!30}
%     \textbf{Dimension} & \textbf{MCP} & \textbf{A2A} & \textbf{ANP} & \textbf{ACP} \\
%     \midrule
%     \textbf{Interaction Mode}
%       & Remote Procedure Call (JSON-RPC)
%       & Task Outsourcing (Tasks \& Artifacts)
%       & Data Crawling (crawl JSON-LD descriptions)
%       & REST-native Task Requests (multi-part messages via broker) \\
%     \hline
%     \textbf{Information Organization}
%       & Full Disclosure (complete tool/resource list)
%       & Capability Cards (high-level skills)
%       & Linked Network (JSON-LD graphs, on-demand)
%       & Agent Detail Manifests (identity, capabilities, runtime health) \\
%     \hline
%     \textbf{Discovery Mechanism}
%       & Discovery RPC (\texttt{tools/list}, \texttt{resources/list})
%       & Agent Cards via HTTP GET or registry API
%       & \texttt{.well-known/agent-descriptions} + linked JSON-LD
%       & Central registry (\texttt{/agents}) \& \texttt{.well-known/agent.yml} \\
%     \hline
%     \textbf{Communication Pattern}
%       & JSON-RPC 2.0 over HTTP(S); SSE optional
%       & JSON-RPC + SSE + Webhooks
%       & HTTP(S) GET/POST with JSON-LD
%       & HTTP POST \texttt{/runs} with ordered MessageParts; sync/async/streaming \\
%     \hline
%     \textbf{Typical Use Case}
%       & LLM integration with external tools
%       & Enterprise-scale multi-agent workflows
%       & Decentralized agent marketplaces
%       & Managed interoperable agent ecosystems with multimodal responses \\
%     \bottomrule
%   \end{tabularx}
% \end{table}

\section{Phased Adoption Roadmap for Agent Interoperability}

This section presents a practical, multi-stage deployment strategy for agent interoperability based on protocol maturity, integration complexity, and use case alignment. The roadmap enables organizations to adopt suitable agent communication standards while supporting scalability, composability, and security.

\subsection{Stage 1 – MCP for Tool Invocation}
The initial phase involves adopting the Model Context Protocol (MCP) to enable structured and secure interaction between large language models (LLMs) and external tools or resources. MCP operates over a JSON-RPC-based client-server model and is well-suited for use cases focused on tool invocation, deterministic execution, and typed input/output. This stage establishes a foundation for context enrichment in single-model systems.

\subsection{Stage 2 – ACP for Agent Communication}
The second phase introduces the Agent Communication Protocol (ACP), a general-purpose, REST-native protocol designed for asynchronous and synchronous communication between independent agents. ACP supports MIME-typed multipart messages, ordered message parts, and streaming. These capabilities enable standardized messaging across agents built on different frameworks, facilitating collaboration and interoperability across organizational and technological boundaries.

\subsection{Stage 3 – A2A for Enterprise Collaboration}
In enterprise-oriented deployments, the Agent-to-Agent (A2A) protocol facilitates multi-agent interaction through Agent Cards and artifact exchanges. It supports dynamic discovery and structured messaging using predefined types, making it well-suited for coordinated workflows among stateless or stateful agents within trusted organizational contexts.

\subsection{Stage 4 – ANP for Open Agent Markets}
The final phase involves extending interoperability to the open internet using the Agent Network Protocol (ANP). ANP facilitates decentralized agent discovery, DID-based identity verification, and peer-to-peer communication using JSON-LD graphs. It provides the foundation for scalable, cross-platform agent marketplaces and AI-native web interaction. This phased approach enables organizations to adopt agent communication protocols progressively, maximizing interoperability while minimizing integration complexity at each stage.

\section{Conclusion}

As autonomous agents powered by large language models proliferate across domains, the demand for secure, modular, and interoperable communication grows increasingly urgent. This survey presented a structured analysis of four emerging protocols MCP, ACP, A2A, and ANP that each address distinct layers of agent interoperability. By unifying tool invocation, multimodal messaging, task coordination, and decentralized discovery, these protocols collectively form the foundation for scalable multi-agent systems. The comparative evaluation demonstrates that no single protocol suffices across all contexts; instead, a phased, complementary adoption strategy—beginning with MCP and progressing through ACP and A2A to ANP offers a practical pathway for deploying agent ecosystems. Future research should explore protocol interoperability bridges, trust frameworks for agent collaboration, and standardized evaluation benchmarks to accelerate adoption and ensure resilience in real-world deployments. These foundational efforts will be critical for advancing the next generation of intelligent, networked agents.




\bibliographystyle{unsrt}  
\bibliography{references}  


\end{document}
